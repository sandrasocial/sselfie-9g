"use server"

import { stripe } from "@/lib/stripe"
import { getProductById } from "@/lib/products"
import { neon } from "@neondatabase/serverless"

const BETA_DISCOUNT_COUPON_ID = process.env.STRIPE_BETA_COUPON_ID || "BETA50" // 50% off coupon

/**
 * Create a Stripe checkout session for landing page (pre-authentication)
 * Updated to use embedded checkout for custom branded experience
 */
export async function createLandingCheckoutSession(productId: string) {
  const product = getProductById(productId)
  if (!product) {
    throw new Error(`Product with id "${productId}" not found`)
  }

  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || process.env.NEXT_PUBLIC_APP_URL || "https://sselfie.ai"

  console.log("[v0] Landing checkout - Product:", productId)
  console.log("[v0] Landing checkout - Product type:", product.type)
  console.log("[v0] Landing checkout - Using baseUrl:", baseUrl)

  // Determine if this is a subscription or one-time payment
  const isSubscription = product.type === "sselfie_studio_membership"

  const discountedPrice = Math.round(product.priceInCents * 0.5) // 50% off

  const session = await stripe.checkout.sessions.create({
    ui_mode: "embedded",
    mode: isSubscription ? "subscription" : "payment",
    redirect_on_completion: "never", // Remove return_url and set redirect_on_completion to never so onComplete callback fires
    line_items: [
      {
        price_data: {
          currency: "usd",
          product_data: {
            name: product.name,
            description: `${product.description} â€¢ BETA PRICING - 50% OFF`,
          },
          unit_amount: discountedPrice, // Apply 50% discount
          ...(isSubscription && {
            recurring: {
              interval: "month",
            },
          }),
        },
        quantity: 1,
      },
    ],
    allow_promotion_codes: true, // Still allow additional promo codes
    ...(isSubscription && {
      subscription_data: {
        metadata: {
          product_id: productId,
          product_type: product.type,
          credits: product.credits?.toString() || "0",
          source: "landing_page",
          beta_discount: "50_percent",
        },
      },
    }),
    metadata: {
      product_id: productId,
      product_type: product.type,
      credits: product.credits?.toString() || "0",
      source: "landing_page",
      beta_discount: "50_percent",
    },
  })

  console.log("[v0] Landing checkout - Created embedded session:", session.id)

  return session.client_secret
}

export const createLandingCheckout = createLandingCheckoutSession

/**
 * Get checkout session details for success page
 */
export async function getCheckoutSession(sessionId: string) {
  try {
    console.log("[v0] Retrieving checkout session:", sessionId)

    const session = await stripe.checkout.sessions.retrieve(sessionId, {
      expand: ["line_items", "customer"],
    })

    console.log("[v0] Session retrieved successfully:", session.id)
    console.log("[v0] Session status:", session.status)

    return {
      status: session.status,
      customerEmail: session.customer_details?.email,
      customerName: session.customer_details?.name,
      subscriptionId: typeof session.subscription === "string" ? session.subscription : session.subscription?.id,
      metadata: session.metadata,
    }
  } catch (error: any) {
    console.error("[v0] Error retrieving checkout session:", error)
    console.error("[v0] Error type:", error?.type)
    console.error("[v0] Error message:", error?.message)
    console.error("[v0] Error code:", error?.code)
    console.error("[v0] Full error:", JSON.stringify(error, null, 2))
    throw error
  }
}

/**
 * Get user information from database using email
 * Avoids Stripe API rate limits by only querying our database
 */
export async function getUserByEmail(email: string) {
  const sql = neon(process.env.DATABASE_URL!)

  try {
    const result = await sql`
      SELECT 
        id,
        email,
        display_name,
        stripe_customer_id,
        supabase_user_id,
        created_at
      FROM users
      WHERE email = ${email}
      LIMIT 1
    `

    if (result.length === 0) {
      return null
    }

    const user = result[0]

    // Get subscription/purchase info
    const subscriptionResult = await sql`
      SELECT 
        product_type,
        status
      FROM subscriptions
      WHERE user_id = ${user.id}
      ORDER BY created_at DESC
      LIMIT 1
    `

    const creditsResult = await sql`
      SELECT balance
      FROM user_credits
      WHERE user_id = ${user.id}
      LIMIT 1
    `

    const emailPrefix = email?.split("@")[0]
    const isAutoGeneratedName = !user.display_name || user.display_name === emailPrefix
    const hasAccount = !isAutoGeneratedName

    return {
      email: user.email,
      displayName: user.display_name,
      hasAccount,
      productType: subscriptionResult[0]?.product_type || null,
      credits: creditsResult[0]?.balance || 0,
    }
  } catch (error: any) {
    console.error("[v0] Error in getUserByEmail:", error.message)
    return null
  }
}

const emailCache = new Map<string, { email: string; timestamp: number }>()
const CACHE_DURATION = 60000 // 1 minute

/**
 * Get user information from database using Stripe session ID
 * Uses caching to avoid hitting Stripe rate limits
 */
export async function getUserByStripeSession(sessionId: string) {
  try {
    // Check cache first
    const cached = emailCache.get(sessionId)
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
      console.log("[v0] Using cached email for session:", sessionId)
      return getUserByEmail(cached.email)
    }

    // Retrieve session from Stripe only once
    const session = await stripe.checkout.sessions.retrieve(sessionId)

    if (!session.customer_details?.email && !session.customer_email) {
      console.log("[v0] No email found in session")
      return null
    }

    const email = session.customer_details?.email || session.customer_email

    // Cache the email
    emailCache.set(sessionId, { email, timestamp: Date.now() })

    // Use database-only lookup
    return getUserByEmail(email)
  } catch (error: any) {
    console.error("[v0] Error in getUserByStripeSession:", error.message)
    return null
  }
}
