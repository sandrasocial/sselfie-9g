import { type NextRequest, NextResponse } from "next/server"
import { getDbClient } from "@/lib/db-singleton"
import { getReplicateClient } from "@/lib/replicate-client"
import { getUserByAuthId } from "@/lib/user-mapping"
import { checkCredits, deductCredits, getUserCredits, CREDIT_COSTS } from "@/lib/credits"
import { getAuthenticatedUser } from "@/lib/auth-helper"
import { rateLimit } from "@/lib/rate-limit-api"
import { generateText } from "ai"

const sql = getDbClient()

async function generatePhotoshootPoseVariations({
  basePrompt,
  baseSeed,
  triggerWord,
  numImages,
  ethnicity,
  physicalPreferences,
}: {
  basePrompt: string
  baseSeed: number
  triggerWord: string
  numImages: number
  ethnicity?: string | null
  physicalPreferences?: string | null
}) {

  let characterDescriptor = ""
  if (ethnicity) {
    characterDescriptor += `${ethnicity} `
  }
  if (physicalPreferences) {
    // Convert instruction language to descriptive language while preserving intent
    let cleanedPreferences = physicalPreferences.trim()
    
    // Check for specific intents BEFORE removing instruction phrases
    const hasNaturalHairColor = /\b(?:keep\s+my\s+natural\s+hair\s+color|keep\s+my\s+natural\s+hair)\b/gi.test(cleanedPreferences)
    const hasDontChangeFace = /\b(?:dont\s+change\s+the\s+face|don't\s+change\s+the\s+face|do\s+not\s+change\s+the\s+face)\b/gi.test(cleanedPreferences)
    
    // Remove instruction phrases - these are for Maya, not FLUX prompts
    const instructionPhrases = [
      /\bAlways keep my\b/gi,
      /\bAlways\s+keep\s+my\s+natural\s+features\b/gi,
      /\bdont change\b/gi,
      /\bdon't change\b/gi,
      /\bdont\s+change\s+the\s+face\b/gi,
      /\bdon't\s+change\s+the\s+face\b/gi,
      /\bkeep my\b/gi,
      /\bkeep\s+my\s+natural\s+features\b/gi,
      /\bkeep\s+my\s+natural\s+eye\s+color\b/gi,
      /\bkeep\s+my\s+natural\s+eyes\b/gi,
      /\bpreserve my\b/gi,
      /\bmaintain my\b/gi,
      /\bdo not change\b/gi,
      /\bdo\s+not\s+change\s+the\s+face\b/gi,
      // Remove "keep my natural hair color" phrase but preserve intent below
      /\bkeep\s+my\s+natural\s+hair\s+color\b/gi,
      /\bkeep\s+my\s+natural\s+hair\b/gi,
    ]
    
    instructionPhrases.forEach((regex) => {
      cleanedPreferences = cleanedPreferences.replace(regex, "")
    })
    
    // PRESERVE INTENT: Convert instructions to descriptive language
    // If user specified "keep natural hair color", convert to descriptive language
    if (hasNaturalHairColor && !/\b(blonde|brown|black|red|gray|grey|auburn|brunette|hair\s+color|natural\s+hair\s+color)\b/gi.test(cleanedPreferences)) {
      cleanedPreferences = "natural hair color, " + cleanedPreferences
    }
    
    // Note: "dont change the face" is preserved by trigger word, so we don't need to add anything
    
    // Clean up commas and spaces
    cleanedPreferences = cleanedPreferences
      .replace(/,\s*,/g, ",") // Remove double commas
      .replace(/,\s*,/g, ",") // Remove double commas again (in case of triple)
      .replace(/^,\s*/, "") // Remove leading comma
      .replace(/\s*,\s*$/, "") // Remove trailing comma
      .replace(/\s+/g, " ") // Normalize multiple spaces
      .trim() // Final trim
    
    // PRESERVE ALL USER MODIFICATIONS - only add if there's actual descriptive content left
    if (cleanedPreferences && cleanedPreferences.length > 0) {
      characterDescriptor += cleanedPreferences
    }
  }

  const characterContext = characterDescriptor.trim()
    ? `\n**Character Consistency:** The person is ${characterDescriptor}. Include this in EVERY prompt variation.`
    : ""

  const mayaPrompt = `You are Maya, creating an authentic "day in the life" Instagram carousel for SSELFIE Studio.

**ORIGINAL CONCEPT PROMPT:**
"${basePrompt}"
${characterContext}

**üéØ CRITICAL CONSISTENCY RULES:**

1. **SAME SEED = SAME APPEARANCE** 
   - All ${numImages} images use IDENTICAL seed ${baseSeed}
   - This ensures consistent face, lighting style, overall aesthetic
   
2. **EXTRACT & REUSE EXACT OUTFIT**
   - Analyze original prompt and extract the EXACT outfit description
   - Use WORD-FOR-WORD identical outfit in all ${numImages} prompts
   - Example: If original says "oversized cream knit sweater, high-waisted jeans" ‚Üí copy this EXACTLY in every variation
   
3. **ONLY VARY: Pose, Angle, Micro-Location**
   - Same outfit ‚úÖ
   - Same character${characterDescriptor ? ` (${characterDescriptor})` : ""} ‚úÖ
   - Same general location ‚úÖ
   - Different pose/action ‚úÖ
   - Different camera angle ‚úÖ
   - Different specific spot within location ‚úÖ

**üìè PROMPT LENGTH: 25-35 words MAX**

Shorter prompts = better facial consistency. The user's LoRA knows their face - don't overwhelm it!

**EXTRACTION PHASE:**

First, extract from original prompt:
- **Exact outfit** (word-for-word, typically 4-8 words)
- **Location type** (cafe, street, beach, etc.)
- **Lighting** (golden hour, soft natural, morning light, etc.)
- **Aesthetic keywords** (1-2 words: cozy, minimal, editorial, etc.)

**VARIATION STRATEGY:**

Think like a real photographer shooting ${numImages} frames in ONE session:
- Frame 1: Wide establishing shot
- Frame 2: Medium walking towards camera
- Frame 3: Close-up candid moment
- Frame 4: Side angle action (sipping, adjusting, etc.)
- Frame 5: Over-shoulder perspective
- Frame 6-9: Natural activity variations

**CRITICAL: USE EXACT SAME OUTFIT DESCRIPTION IN EVERY PROMPT**

**PROMPT STRUCTURE (25-35 words):**
"${triggerWord}, ${characterDescriptor ? characterDescriptor + ", " : ""}[exact_outfit_from_original], [simple_action], [micro_location], [lighting], shot on iPhone 15 Pro, [lens], natural skin texture"

**CAPTION EXAMPLES:**
‚úÖ "Cozy fall vibes in my favorite sweater"
‚úÖ "Living for this effortless minimalist moment"
‚úÖ "City streets and coffee dates"
‚úÖ "That golden hour glow hits different"
‚ùå "White woman, Long dark knit texture..." (too technical)
‚ùå "Beautiful woman in oversized sweater..." (too generic)

**WHAT TO EXCLUDE:**
- NO "beautiful", "stunning", "gorgeous" 
- NO detailed environmental descriptions
- NO complex pose instructions
- Keep it MINIMAL for face preservation

**OUTPUT - RETURN ONLY THIS JSON:**

{
  "extractedOutfit": "exact outfit description copied word-for-word from original (no changes)",
  "locationTheme": "general location type",
  "lightingStyle": "lighting description",
  "baseSeed": ${baseSeed},
  "poses": [
    {
      "title": "Brief Pose Name (2-4 words)",
      "caption": "Trendy Instagram-style caption (8-12 words max, everyday language, mood/vibe focused, NO technical descriptions)",
      "shotType": "full body" | "medium shot" | "close-up",
      "scenery": "specific micro-location",
      "action": "simple activity (2-4 words)",
      "cameraAngle": "straight" | "side" | "above" | "over shoulder",
      "lensChoice": "35mm" | "50mm" | "85mm",
      "prompt": "${triggerWord}, ${characterDescriptor ? characterDescriptor + ", " : ""}[exact_outfit], [action], [micro_location], [lighting], shot on iPhone 15 Pro, [lens], natural skin texture"
    }
  ]
}

**VALIDATION CHECKS:**
‚úÖ extractedOutfit is IDENTICAL to original (word-for-word)
‚úÖ Every pose uses EXACT SAME outfit description
‚úÖ Every prompt is 25-35 words
‚úÖ Every caption is 8-12 words, trendy, everyday language
‚úÖ Only pose/angle/micro-location vary

Generate ${numImages} lifestyle variations. Return ONLY valid JSON.`

  const { text } = await generateText({
    model: "anthropic/claude-sonnet-4.5",
    prompt: mayaPrompt,
    maxOutputTokens: 4000,
    temperature: 0.7, // Reduced from 0.85 for more consistency
  })


  let jsonText = text

  if (text.includes("```json")) {
    const jsonMatch = text.match(/```json\s*([\s\S]*?)\s*```/)
    if (jsonMatch) {
      jsonText = jsonMatch[1]
    }
  } else if (text.includes("```")) {
    const jsonMatch = text.match(/```\s*([\s\S]*?)\s*```/)
    if (jsonMatch) {
      jsonText = jsonMatch[1]
    }
  }

  const jsonMatch = jsonText.match(/\{[\s\S]*\}/)
  if (!jsonMatch) {
    console.error("[v0] ‚ùå No JSON found in response:", text.substring(0, 500))
    throw new Error("No JSON found in Maya response")
  }

  try {
    const photoshootPlan = JSON.parse(jsonMatch[0])
    
    // Get user data
    const { getEffectiveNeonUser } = await import("@/lib/simple-impersonation")
    const neonUser = await getEffectiveNeonUser(user.id)
    if (!neonUser) {
      return NextResponse.json({ error: "User not found" }, { status: 404 })
    }

    const userDataResult = await sql`
      SELECT 
        replicate_model_id,
        replicate_version_id,
        lora_scale,
        lora_weights_url,
        ethnicity,
        physical_preferences
      FROM user_models
      WHERE user_id = ${neonUser.id}
      AND training_status = 'completed'
      ORDER BY created_at DESC
      LIMIT 1
    `

    if (userDataResult.length === 0) {
      return NextResponse.json(
        { error: "No trained model found. Please train your model first." },
        { status: 400 }
      )
    }

    const userData = userDataResult[0]
    const replicateModelId = userData.replicate_model_id
    const userLoraScale = userData.lora_scale
    const loraWeightsUrl = userData.lora_weights_url
    const ethnicity = userData.ethnicity
    const physicalPreferences = userData.physical_preferences

    let versionHash = replicateVersionId
    if (replicateVersionId && replicateVersionId.includes(":")) {
      versionHash = replicateVersionId.split(":").pop()
    }

    const userLoraPath = replicateModelId && versionHash ? `${replicateModelId}:${versionHash}` : loraWeightsUrl

    if (!userLoraPath || userLoraPath.trim() === "") {
      return NextResponse.json(
        { error: "LoRA model not found. Please contact support to fix your model." },
        { status: 400 },
      )
    }

    const consistencySeed = heroSeed || Math.floor(Math.random() * 1000000)


    const photoshootPlan = await generatePhotoshootPoseVariations({
      basePrompt: heroPrompt,
      baseSeed: consistencySeed,
      triggerWord,
      numImages: NUM_IMAGES,
      ethnicity,
      physicalPreferences,
    })

    const replicate = getReplicateClient()

    let finalSettings
    if (customSettings) {
      const { MAYA_QUALITY_PRESETS } = await import("@/lib/maya/quality-settings")
      const categoryKey = category as keyof typeof MAYA_QUALITY_PRESETS
      const presetSettings = MAYA_QUALITY_PRESETS[categoryKey] || MAYA_QUALITY_PRESETS.default

      finalSettings = {
        ...presetSettings,
        guidance_scale: customSettings.promptAccuracy || presetSettings.guidance_scale,
        lora_scale: customSettings.styleStrength || Number(userLoraScale || presetSettings.lora_scale),
        extra_lora_scale: customSettings.realismStrength || presetSettings.extra_lora_scale,
        // Keep aspect_ratio from preset (can be overridden if needed)
        aspect_ratio: presetSettings.aspect_ratio,
      }
    } else {
      const { MAYA_QUALITY_PRESETS } = await import("@/lib/maya/quality-settings")
      const categoryKey = category as keyof typeof MAYA_QUALITY_PRESETS
      const presetSettings = MAYA_QUALITY_PRESETS[categoryKey] || MAYA_QUALITY_PRESETS.default
      finalSettings = {
        ...presetSettings,
        lora_scale: Number(userLoraScale || presetSettings.lora_scale),
      }
    }

    const REALISM_LORA_URL =
      customSettings?.extraLora ||
      "https://huggingface.co/strangerzonehf/Flux-Super-Realism-LoRA/resolve/main/super-realism.safetensors"


    const predictions: Array<{
      predictionId: string
      title: string
      description: string
      pose: string
      location: string
      seed: number
      index: number
      shotDistance?: string
      energyLevel?: string
      caption: string
    }> = []


    for (let i = 0; i < NUM_IMAGES; i++) {
      const pose = photoshootPlan.poses[i]
      const sameSeed = consistencySeed


      if (i < NUM_IMAGES - 1) {
        await new Promise((resolve) => setTimeout(resolve, 11000))
      }
    }

    const insertResult = await sql`
      INSERT INTO generated_images (
        user_id,
        prompt,
        description,
        category,
        subcategory,
        image_urls,
        created_at
      ) VALUES (
        ${String(neonUser.id)},
        ${heroPrompt},
        ${`Photoshoot: ${predictions.map((p) => p.title).join(", ")}`},
        ${category},
        ${conceptTitle},
        ${JSON.stringify({
          predictions: predictions,
          baseOutfit: photoshootPlan.extractedOutfit,
          status: "processing",
          total_images: NUM_IMAGES,
          base_seed: consistencySeed,
          hero_image: heroImageUrl,
          generation_type: "photoshoot_single_predictions",
          user_id: String(neonUser.id),
          custom_settings: finalSettings,
        })},
        NOW()
      )
      RETURNING id
    `

    const deductionResult = await deductCredits(
      neonUser.id,
      totalCreditsRequired,
      "image",
      `Photoshoot: ${conceptTitle} (${NUM_IMAGES} images)`,
      predictions[0].predictionId,
    )

      totalImages: NUM_IMAGES,
      predictions: predictions.length,
      baseSeed: consistencySeed,
      seedRange: `${consistencySeed} to ${consistencySeed + NUM_IMAGES - 1}`,
      basePrompt: heroPrompt.substring(0, 80) + "...",
      creditsDeducted: totalCreditsRequired,
      newBalance: deductionResult.newBalance,
      ethnicity: ethnicity || "not specified",
      physicalPreferences: physicalPreferences || "not specified",
    })

    return NextResponse.json({
      success: true,
      photoshootId: insertResult[0].id,
      predictions: predictions,
      totalImages: NUM_IMAGES,
      baseOutfit: photoshootPlan.extractedOutfit,
      baseSeed: consistencySeed,
      creditsDeducted: totalCreditsRequired,
      newBalance: deductionResult.success ? deductionResult.newBalance : undefined,
      userId: String(neonUser.id),
    })
  } catch (error) {
    console.error("[v0] Error creating photoshoot:", error)
    return NextResponse.json(
      {
        error: "Failed to create photoshoot",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 },
    )
  }
}
