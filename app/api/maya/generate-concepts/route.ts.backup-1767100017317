import { type NextRequest, NextResponse } from "next/server"
import { createServerClient } from "@/lib/supabase/server"
import { getAuthenticatedUser } from "@/lib/auth-helper"
import { generateText } from "ai"
import { getFluxPromptingPrinciples } from "@/lib/maya/flux-prompting-principles"
import { getFashionIntelligencePrinciples } from "@/lib/maya/fashion-knowledge-2025"
import { getLifestyleContextIntelligence } from "@/lib/maya/lifestyle-contexts"
import INFLUENCER_POSING_KNOWLEDGE from "@/lib/maya/influencer-posing-knowledge"
import INSTAGRAM_LOCATION_INTELLIGENCE from "@/lib/maya/instagram-location-intelligence"
import { getLuxuryLifestyleSettings } from "@/lib/maya/luxury-lifestyle-settings"
import { getNanoBananaPromptingPrinciples } from "@/lib/maya/nano-banana-prompt-builder"
import { getConceptPrompt } from "@/lib/maya/concept-templates"
import {
  shouldIncludeSkinTexture,
  mergeGuidePromptWithImages,
  extractPromptElements,
  createVariationFromGuidePrompt,
  type ReferenceImages
} from "@/lib/maya/prompt-builders/guide-prompt-handler"
import { SHARED_MAYA_PERSONALITY } from "@/lib/maya/personality/shared-personality"
import { getMayaPersonality } from "@/lib/maya/personality-enhanced"
import { MAYA_SYSTEM_PROMPT } from "@/lib/maya/personality"
import { generateCompleteOutfit } from "@/lib/maya/brand-library-2025"
import { 
  buildPrompt, 
  buildPromptWithFeatures, 
  validatePromptLength,
  type PromptConstructorParams 
} from "@/lib/maya/prompt-constructor"
import { buildEnhancedPrompt, type EnhancedPromptParams } from "@/lib/maya/prompt-constructor-enhanced"
import { 
  findMatchingPrompt, 
  getRandomPrompts,
  getPromptsForCategory,
  getPromptById,
  type UniversalPrompt 
} from "@/lib/maya/universal-prompts"
import {
  applyProgrammaticFixes,
  validatePromptLight,
  type DirectPromptContext
} from '@/lib/maya/direct-prompt-generation'
import { generateWithNanoBanana, checkNanoBananaPrediction } from '@/lib/nano-banana-client'
import { put } from '@vercel/blob'

/**
 * Direct Prompt Generation
 * 
 * Maya generates final prompts directly for all concepts.
 */

type MayaConcept = {
  title: string
  description: string
  category: string
  fashionIntelligence: string
  lighting: string
  location: string
  prompt: string
  customSettings?: {
    styleStrength?: number
    promptAccuracy?: number
    aspectRatio?: string
    seed?: number
  }
  referenceImageUrl?: string
  imageUrl?: string // Optional: URL of generated image (for consistency mode with reference images)
  predictionId?: string // Optional: Prediction ID for tracking generation status
  referenceImages?: string[] // Optional: Array of reference image URLs used for generation
}

/**
 * Consistency Mode for Concept Generation
 * - variety: Each concept has different outfit/location/scene (default)
 * - consistent: All concepts use same outfit/location/lighting, only vary poses/angles
 */
type ConsistencyMode = 'variety' | 'consistent'

// Guide prompt handler functions are now imported from lib/maya/prompt-builders/guide-prompt-handler.ts

/**
 * Detect category from user request with improved mapping to Universal Prompt categories
 * Directly maps to Universal Prompt categories for better accuracy
 */
function detectCategoryFromRequest(
  userRequest?: string,
  aesthetic?: string,
  context?: string,
  conversationContext?: string
): string | null {
  // Include conversationContext for better context detection (like Classic Mode)
  const combined = `${userRequest || ''} ${aesthetic || ''} ${context || ''} ${conversationContext || ''}`.toLowerCase()
  
  // Travel & Airport (most specific patterns first)
  if (combined.match(/airport|travel|flight|plane|luggage|suitcase|departure|arrival|gate|boarding|baggage|terminal/i)) {
    return 'travel-airport'
  }
  
  // Ski / AprÃ¨s-ski / Mountain (before Christmas to avoid false matches)
  if (combined.match(/afterski|aprÃ¨s.?ski|aprÃ¨s ski|after.?ski|ski resort|skiing|mountain lodge|norway|switzerland|alps|snowboarding/i)) {
    return 'luxury-fashion' // Map to luxury for ski/aprÃ¨s-ski lifestyle
  }
  
  // Athletic / Workout / Alo
  if (combined.match(/workout|gym|athletic|yoga|fitness|pilates|tennis|sport|alo|lululemon|training|exercise/i)) {
    return 'alo-workout'
  }
  
  // Christmas / Holiday / Seasonal (more specific to avoid false matches)
  if (combined.match(/christmas|holiday|festive|seasonal|winter party|nye|new year|tree|gifts|presents|christmas tree|christmas morning|christmas market/i)) {
    return 'seasonal-christmas'
  }
  
  // Luxury / Fashion / Editorial
  if (combined.match(/luxury|elegant|sophisticated|designer|chanel|bottega|hotel|marble|editorial|high.?end|premium|couture/i)) {
    return 'luxury-fashion'
  }
  
  // Casual Lifestyle (more specific - don't match on generic words alone)
  if (combined.match(/casual|lifestyle|coffee|everyday|relatable|street/i)) {
    return 'casual-lifestyle'
  }
  
  // Cozy/Home (require explicit "cozy" keyword, not just "comfortable")
  if (combined.match(/\bcozy\b|home|lounge/i) && !combined.match(/luxury|elegant|sophisticated/i)) {
    return 'casual-lifestyle' // Map cozy to casual-lifestyle
  }
  
  // ðŸ”´ FIX: Only default to 'casual-lifestyle' if we have meaningful text to analyze
  // If combined is empty or just whitespace, return special marker to allow fallback to upload module category
  const hasUserRequest = userRequest && userRequest.trim().length > 0
  const hasAesthetic = aesthetic && aesthetic.trim().length > 0
  const hasContext = context && context.trim().length > 0
  const hasConversationContext = conversationContext && conversationContext.trim().length > 0
  const hasMeaningfulText = combined.trim().length > 0 && (hasUserRequest || hasAesthetic || hasContext || hasConversationContext)
  
  if (!hasMeaningfulText) {
    // No meaningful text - return special marker to allow fallback to upload module category
    return '' // Return empty string instead of null (callers can check for empty)
  }
  
    // We have text but no patterns matched - return null to allow dynamic generation
    // This is likely an aesthetic description (e.g., "pinterest influencer aesthetic") not a category
    return null // Return null instead of defaulting - allows Maya to use full fashion knowledge
}

/**
 * Map category from detectCategoryFromRequest format to generateCompleteOutfit format
 * detectCategoryFromRequest now returns: 'travel-airport', 'alo-workout', 'seasonal-christmas', 'casual-lifestyle', 'luxury-fashion'
 * generateCompleteOutfit expects: 'workout', 'travel', 'casual', 'cozy', etc.
 * Returns null if category doesn't map to a supported generateCompleteOutfit category
 */
function mapCategoryForBrandLibrary(mappedCategory: string | null, userRequest?: string): string | null {
  // Guard against null category
  if (!mappedCategory || typeof mappedCategory !== 'string') {
    return null
  }
  
  const categoryLower = mappedCategory.toLowerCase()
  const requestLower = (userRequest || '').toLowerCase()
  
  // Only map categories that generateCompleteOutfit actually supports
  // Supported categories: 'workout', 'athletic', 'gym', 'casual', 'coffee-run', 
  // 'street-style', 'travel', 'airport', 'cozy', 'home'
  
  // Map Universal Prompt categories to brand library categories
  if (categoryLower === 'alo-workout' || categoryLower.includes('workout') || categoryLower === 'athletic' || categoryLower === 'gym') {
    return 'workout'
  }
  if (categoryLower === 'travel-airport' || categoryLower.includes('travel') || categoryLower === 'airport') {
    return 'travel'
  }
  if (categoryLower === 'casual-lifestyle') {
    // For casual-lifestyle, infer from user request context
    if (/coffee|cafe|coffeeshop/i.test(requestLower)) {
      return 'coffee-run'
    }
    if (/street|urban|city|soho/i.test(requestLower)) {
      return 'street-style'
    }
    // Default to 'casual' for casual-lifestyle
    return 'casual'
  }
  if (categoryLower === 'luxury-fashion' || categoryLower === 'luxury') {
    return 'luxury'
  }
  if (categoryLower === 'seasonal-christmas' || (categoryLower === 'cozy' && /christmas|holiday|winter/i.test(requestLower))) {
    // Christmas maps to cozy for brand library
    return 'cozy'
  }
  
  // Legacy category mappings (for backward compatibility)
  if (categoryLower === 'travel-lifestyle') {
    return 'travel'
  }
  if (categoryLower === 'lifestyle-wellness') {
    // For lifestyle-wellness, infer from user request context
    if (/cozy|home|comfort|lounge|relax/i.test(requestLower)) {
      return 'cozy'
    }
    if (/street|urban|city/i.test(requestLower)) {
      return 'street-style'
    }
    // Default to 'casual' for lifestyle-wellness when no specific context is detected
    return 'casual'
  }
  
  // No fallbacks - return null for unmapped categories
  // This prevents unwanted brand injection for categories like:
  // 'beauty', 'tech', 'selfies'
  return null
}

/**
 * Enhanced category detection for prompt constructor
 * Maps user input to prompt constructor categories
 */
function detectCategoryForPromptConstructor(
  userRequest?: string,
  aesthetic?: string,
  context?: string,
  conversationContext?: string
): { category: string | null; vibe: string | null; location: string | null; wasDetected: boolean; isAestheticDescription?: boolean } {
  // Include conversationContext for better context detection (like Classic Mode)
  const combinedText = `${userRequest || ''} ${aesthetic || ''} ${context || ''} ${conversationContext || ''}`.toLowerCase()
  
  // ðŸ”´ FIX: Track if category was actually detected (not defaulted)
  let category: string | null = null
  let vibe: string | null = null
  let location: string | null = null
  let wasDetected = false
  
  // Workout/Athletic
  if (/workout|gym|fitness|athletic|exercise|training/.test(combinedText)) {
    category = 'workout'
    vibe = 'athletic'
    location = 'gym'
    wasDetected = true
  }
  // Casual/Coffee
  else if (/coffee|casual|errands|running errands|coffee run/.test(combinedText)) {
    category = 'casual'
    vibe = 'casual'
    location = 'coffee-shop'
    wasDetected = true
  }
  // Street Style
  else if (/street style|street-style|fashion|urban|soho|city/.test(combinedText)) {
    category = 'street-style'
    vibe = 'street-style'
    location = 'street'
    wasDetected = true
  }
  // Ski / AprÃ¨s-ski / Mountain (before travel to catch specific requests)
  else if (/afterski|aprÃ¨s.?ski|aprÃ¨s ski|after.?ski|ski resort|skiing|mountain lodge|norway|switzerland|alps|snowboarding/.test(combinedText)) {
    category = 'luxury'
    vibe = 'luxury'
    location = 'mountain lodge' // Will be overridden by specific location if mentioned
    wasDetected = true
  }
  // Travel/Airport
  else if (/airport|travel|traveling|flying|terminal/.test(combinedText)) {
    category = 'travel'
    vibe = 'travel'
    location = 'airport'
    wasDetected = true
  }
  // Luxury (check BEFORE cozy to catch "comfortable luxury" etc.)
  else if (/luxury|chic|elegant|sophisticated|refined/.test(combinedText)) {
    category = 'luxury'
    vibe = 'luxury'
    location = 'luxury location'
    wasDetected = true
  }
  // Cozy/Home (require explicit "cozy" keyword, not just "comfortable")
  else if (/\bcozy\b|home|lounge/i.test(combinedText) && !/luxury|elegant|sophisticated/i.test(combinedText)) {
    category = 'cozy'
    vibe = 'cozy'
    location = 'home'
    wasDetected = true
  }
  // Christmas/Holiday (check BEFORE cozy to catch Christmas requests)
  else if (/christmas|holiday|festive|winter party|nye|new year|tree|gifts|presents|christmas tree|christmas morning|christmas market/i.test(combinedText)) {
    category = 'cozy' // Map to cozy for brand library (Christmas uses cozy category)
    vibe = 'cozy' // But keep vibe as cozy for Christmas aesthetic
    location = 'home' // Christmas is typically home-based
    wasDetected = true
  }
  
  // Extract location hints from text - only override if location wasn't already set by category
  // This preserves category-location relationships (e.g., workout -> gym)
  // But allows explicit location mentions to override (e.g., "workout at home" -> home)
  if (location === 'street' || location === 'luxury location' || location === 'mountain lodge') {
    // Only override default locations, not category-specific ones
    if (/afterski|aprÃ¨s.?ski|aprÃ¨s ski|after.?ski|ski resort|mountain lodge|norway|switzerland|alps/.test(combinedText)) {
      location = 'mountain lodge'
    } else if (/gym|fitness center|studio/.test(combinedText)) location = 'gym'
    else if (/coffee|cafe|coffeeshop/.test(combinedText)) location = 'coffee-shop'
    else if (/airport|terminal|gate/.test(combinedText)) location = 'airport'
    else if (/home|house|apartment|living room/.test(combinedText)) location = 'home'
    else if (/street|soho|city|urban/.test(combinedText)) location = 'street'
  } else {
    // For category-specific locations, only override if there's an explicit location mention
    // that conflicts with the category default (e.g., "workout at home" -> home)
    if (/afterski|aprÃ¨s.?ski|aprÃ¨s ski|after.?ski|ski resort|mountain lodge|norway|switzerland|alps/.test(combinedText)) {
      location = 'mountain lodge'
    } else if (/home|house|apartment|living room/.test(combinedText) && location !== 'home') {
      location = 'home'
    } else if (/gym|fitness center|studio/.test(combinedText) && location !== 'gym') {
      location = 'gym'
    } else if (/coffee|cafe|coffeeshop/.test(combinedText) && location !== 'coffee-shop') {
      location = 'coffee-shop'
    } else if (/airport|terminal|gate/.test(combinedText) && location !== 'airport') {
      location = 'airport'
    } else if (/street|soho|city|urban/.test(combinedText) && location !== 'street') {
      location = 'street'
    }
  }
  
  // ðŸ”´ FIX: Return null when no patterns match - allow dynamic generation instead of forcing defaults
  // If combinedText is empty or just whitespace, mark as not detected to allow fallback to upload module category
  if (category === null && vibe === null && location === null) {
    // No patterns matched - check if we have meaningful text to analyze
    const hasUserRequest = userRequest && typeof userRequest === 'string' && userRequest.trim().length > 0
    const hasAesthetic = aesthetic && typeof aesthetic === 'string' && aesthetic.trim().length > 0
    const hasContext = context && typeof context === 'string' && context.trim().length > 0
    const hasConversationContext = conversationContext && typeof conversationContext === 'string' && conversationContext.trim().length > 0
    const hasMeaningfulText = combinedText.trim().length > 0 && (hasUserRequest || hasAesthetic || hasContext || hasConversationContext)
    
    if (!hasMeaningfulText) {
      // No meaningful text - mark as not detected to allow fallback to upload module category
      wasDetected = false
      // Return null to allow dynamic generation
      return { category: null, vibe: null, location: null, wasDetected: false, isAestheticDescription: false }
    }
    
    // We have text but no patterns matched - this is likely an aesthetic description, not a category
    // Return null to allow Maya to use her full fashion knowledge dynamically
    // Check if it looks like an aesthetic description (contains words like "aesthetic", "style", "vibe", "curated", "dreamy", etc.)
    const aestheticKeywords = /aesthetic|style|vibe|curated|dreamy|feminine|minimal|luxury|editorial|pinterest|instagram|influencer/i
    const isAestheticDescription = aestheticKeywords.test(combinedText)
    
    return { 
      category: null, 
      vibe: null, 
      location: null, 
      wasDetected: false, 
      isAestheticDescription: isAestheticDescription 
    }
  }
  
  return { 
    category: category || null, 
    vibe: vibe || null, 
    location: location || null, 
    wasDetected: wasDetected 
  }
}

/**
 * Extract user age from physical preferences or default
 */
function extractUserAge(physicalPreferences?: string | null): string | undefined {
  if (!physicalPreferences) return undefined
  
  const ageMatch = physicalPreferences.match(/(?:age|aged?|years? old)\s*:?\s*(\d+)/i)
  if (ageMatch) {
    const age = parseInt(ageMatch[1])
    if (age >= 20 && age < 30) return 'Woman in late twenties'
    if (age >= 30 && age < 40) return 'Woman in early thirties'
    if (age >= 40) return 'Woman in forties'
  }
  
  return undefined
}

/**
 * Map upload module concept value to specific universal prompt ID
 * This ensures each concept (e.g., "christmas-party") maps to the correct prompt
 */
function mapConceptToPromptId(category: string, conceptValue: string): string | null {
  const categoryLower = category.toLowerCase()
  const conceptLower = conceptValue.toLowerCase().trim()
  
  // Christmas/Holiday concepts
  if (categoryLower === 'seasonal-holiday' || categoryLower === 'seasonal-christmas') {
    if (conceptLower.includes('party') || conceptLower.includes('dinner') || conceptLower.includes('evening')) {
      return 'christmas-dinner-party-1'
    }
    if (conceptLower.includes('morning')) {
      return 'christmas-morning-coffee-1'
    }
    if (conceptLower.includes('market') || conceptLower.includes('shopping')) {
      return 'christmas-market-outdoor-1'
    }
    if (conceptLower.includes('baking') || conceptLower.includes('cookie')) {
      return 'christmas-baking-cookies-1'
    }
    if (conceptLower.includes('tree') && conceptLower.includes('decorat')) {
      return 'christmas-tree-decorating-1'
    }
    if (conceptLower.includes('gift') || conceptLower.includes('wrapping')) {
      return 'christmas-gift-wrapping-1'
    }
    if (conceptLower.includes('reading') || conceptLower.includes('cozy')) {
      return 'christmas-reading-nook-1'
    }
    if (conceptLower.includes('walk') || conceptLower.includes('winter') || conceptLower.includes('snow')) {
      return 'christmas-winter-walk-1'
    }
    if (conceptLower.includes('fireplace') || conceptLower.includes('fire')) {
      return 'christmas-fireplace-morning-1'
    }
    // Default to elegant dinner party for generic "party" or "christmas-party"
    if (conceptLower.includes('christmas') || conceptLower === 'party') {
      return 'christmas-dinner-party-1'
    }
  }
  
  // Travel/Airport concepts
  if (categoryLower === 'travel-lifestyle' || categoryLower === 'travel-airport') {
    if (conceptLower.includes('lounge') || conceptLower.includes('airport')) {
      return 'travel-airport-lounge-1'
    }
    if (conceptLower.includes('departure') || conceptLower.includes('leaving')) {
      return 'travel-airport-departure-1'
    }
    if (conceptLower.includes('walking') || conceptLower.includes('terminal')) {
      return 'travel-airport-walking-1'
    }
    if (conceptLower.includes('escalator') || conceptLower.includes('motion')) {
      return 'travel-airport-escalator-1'
    }
    if (conceptLower.includes('baggage') || conceptLower.includes('claim')) {
      return 'travel-airport-baggage-claim-1'
    }
    if (conceptLower.includes('exit') || conceptLower.includes('taxi')) {
      return 'travel-airport-taxi-exit-1'
    }
  }
  
  // Workout/Athletic concepts
  if (categoryLower === 'wellness-content' || categoryLower === 'alo-workout') {
    if (conceptLower.includes('yoga') && conceptLower.includes('studio')) {
      return 'alo-yoga-studio-warrior-1'
    }
    if (conceptLower.includes('tennis')) {
      return 'alo-tennis-court-1'
    }
    if (conceptLower.includes('running') || conceptLower.includes('trail')) {
      return 'alo-outdoor-running-1'
    }
    if (conceptLower.includes('pilates') || conceptLower.includes('reformer')) {
      return 'alo-pilates-reformer-1'
    }
    if (conceptLower.includes('gym') || conceptLower.includes('weights') || conceptLower.includes('strength')) {
      return 'alo-gym-weights-1'
    }
    if (conceptLower.includes('beach') && conceptLower.includes('yoga')) {
      return 'alo-beach-yoga-sunset-1'
    }
  }
  
  // Casual Lifestyle concepts
  if (categoryLower === 'casual-lifestyle') {
    if (conceptLower.includes('coffee') || conceptLower.includes('cafe')) {
      return 'casual-coffee-shop-1'
    }
    if (conceptLower.includes('morning') && (conceptLower.includes('routine') || conceptLower.includes('bathroom'))) {
      return 'casual-bathroom-morning-1'
    }
    if (conceptLower.includes('market') || conceptLower.includes('grocery') || conceptLower.includes('farmers')) {
      return 'casual-grocery-market-1'
    }
    if (conceptLower.includes('office') || conceptLower.includes('work') || conceptLower.includes('laptop')) {
      return 'casual-home-office-laptop-1'
    }
    if (conceptLower.includes('cooking') || conceptLower.includes('dinner') || conceptLower.includes('kitchen')) {
      return 'casual-cooking-dinner-1'
    }
    if (conceptLower.includes('reading') || conceptLower.includes('couch') || conceptLower.includes('evening')) {
      return 'casual-couch-reading-evening-1'
    }
  }
  
  return null
}

/**
 * Map internal category to Universal Prompts library category
 * Now simplified since detectCategoryFromRequest already returns Universal Prompt categories
 */
function mapToUniversalPromptCategory(category: string, userRequest?: string): string | null {
  // detectCategoryFromRequest now directly returns Universal Prompt categories
  // So we can use it directly, but we also need to handle prompt constructor categories
  const categoryLower = category.toLowerCase()
  const requestLower = (userRequest || '').toLowerCase()
  
  // If category is already a Universal Prompt category, return it
  if (['travel-airport', 'alo-workout', 'seasonal-christmas', 'casual-lifestyle', 'luxury-fashion'].includes(categoryLower)) {
    return categoryLower
  }
  
  // Map prompt constructor categories to Universal Prompt categories
  // Travel/Airport
  if (categoryLower === 'travel' || categoryLower === 'airport' || 
      /airport|travel|traveling|flying|terminal/.test(requestLower)) {
    return 'travel-airport'
  }
  
  // Alo/Workout
  if (categoryLower === 'workout' || categoryLower === 'athletic' || categoryLower === 'gym' ||
      /alo|yoga|workout|gym|fitness|athletic/.test(requestLower)) {
    return 'alo-workout'
  }
  
  // Christmas/Holiday
  if (categoryLower === 'cozy' && /christmas|holiday|winter|snow/.test(requestLower)) {
    return 'seasonal-christmas'
  }
  
  // Casual Lifestyle
  if (categoryLower === 'casual' || categoryLower === 'coffee-run' ||
      /coffee|casual|errands|everyday/.test(requestLower)) {
    return 'casual-lifestyle'
  }
  
  // Luxury Fashion
  if (categoryLower === 'luxury' || categoryLower === 'street-style' ||
      /luxury|chic|elegant|sophisticated|designer/.test(requestLower)) {
    return 'luxury-fashion'
  }
  
  return null
}

/**
 * Validate prompt matches production requirements
 */
function validateProductionPrompt(prompt: string): { valid: boolean; warnings: string[] } {
  const warnings: string[] = []
  const wordCount = prompt.split(/\s+/).length
  
  // Check word count (250-500 words)
  if (wordCount < 250) {
    warnings.push(`Prompt too short: ${wordCount} words (minimum 250 words)`)
  }
  if (wordCount > 500) {
    warnings.push(`Prompt too long: ${wordCount} words (maximum 500 words)`)
  }
  
  // Check for camera specs
  if (!/mm|lens|Camera|camera|f\/|f\s*\d/.test(prompt)) {
    warnings.push('Missing camera specs (lens, mm, f-stop)')
  }
  
  // Check for lighting
  if (!/light|lighting|sunlight|daylight|ambient/.test(prompt)) {
    warnings.push('Missing lighting description')
  }
  
  // Check for brands (at least one) - expanded list to include all top brands
  const brandPattern = /Alo Yoga|Lululemon|Adidas|Levi's|Nike|New Balance|Bottega|Cartier|UGG|The Row|Chanel|HermÃ¨s|Common Projects|New Era|Ray-Ban|Agolde|Zara|COS|Everlane|Reformation|Toteme|Skims|Khy/i
  if (!brandPattern.test(prompt)) {
    warnings.push('Missing brand names')
  }
  
  // Check for resolution/quality
  if (!/4K|8K|hyper-realistic|hyper realistic/.test(prompt)) {
    warnings.push('Missing resolution/quality spec (4K, 8K, or hyper-realistic)')
  }
  
  return {
    valid: warnings.length === 0,
    warnings,
  }
}

/**
 * Generate a prompt using the brand library and prompt constructor system
 * This can be used as an alternative to the composition system for Studio Pro mode
 */
function generatePromptWithBrandLibrary(
  userRequest: string,
  userGender: string,
  physicalPreferences?: string | null,
  triggerWord?: string,
  aesthetic?: string,
  context?: string,
  categoryOverride?: string | null,
  vibeOverride?: string | null,
  locationOverride?: string | null
): string {
  // Detect category, vibe, and location (use overrides if provided to preserve context)
  const detected = categoryOverride !== undefined && vibeOverride !== undefined && locationOverride !== undefined
    ? { category: categoryOverride, vibe: vibeOverride, location: locationOverride, wasDetected: true, isAestheticDescription: false }
    : detectCategoryForPromptConstructor(userRequest, aesthetic, context)
  
  // ðŸ”´ FIX: If category not detected, allow dynamic generation instead of forcing defaults
  if (!detected.wasDetected && !detected.category) {
    // Category not detected - this is likely an aesthetic description
    // Use Maya's fashion knowledge and AI generation instead of category-specific templates
    // Return empty string to signal caller should use AI generation
    // The caller will handle this by using AI generation path
    return ''
  }
  
  // Category detected - use prompt constructor
  const { category, vibe, location } = detected
  
  // Extract user age
  const userAge = extractUserAge(physicalPreferences)
  
  // Extract hair style from physical preferences if available
  let hairStyle: string | undefined
  if (physicalPreferences) {
    const hairMatch = physicalPreferences.match(/(?:hair|hairstyle)[^.]*?([^.]*)/i)
    if (hairMatch) {
      hairStyle = hairMatch[1].trim()
    }
  }
  
  // Build prompt using prompt constructor
  // Note: Only pass physicalPreferences once to avoid duplication in buildPromptWithFeatures
  const prompt = buildPromptWithFeatures({
    category: category!, // Non-null assertion since we checked above
    vibe: vibe!,
    location: location!,
    userAge,
    userFeatures: physicalPreferences || undefined, // Use userFeatures, not physicalPreferences to avoid duplication
    userGender,
    hairStyle,
    triggerWord,
    userRequest, // Pass userRequest to preserve context (e.g., Christmas)
    // Don't pass physicalPreferences separately - it's the same as userFeatures
  })
  
  // Validate the prompt
  const validation = validateProductionPrompt(prompt)
  if (!validation.valid) {
    console.warn('[v0] [PROMPT-CONSTRUCTOR] Prompt validation warnings:', validation.warnings)
  }
  
  // Also check word count using prompt constructor validation
  const lengthValidation = validatePromptLength(prompt)
  if (!lengthValidation.valid) {
    console.warn('[v0] [PROMPT-CONSTRUCTOR]', lengthValidation.message)
  }
  
  return prompt
}

/**
 * Helper: Detect brand from text
 */
function detectBrand(text?: string): string | undefined {
  if (!text) return undefined

  const lower = text.toLowerCase()

  if (lower.includes('alo')) return 'ALO'
  if (lower.includes('chanel')) return 'CHANEL'
  if (lower.includes('lululemon') || lower.includes('lulu')) return 'LULULEMON'
  if (lower.includes('glossier')) return 'GLOSSIER'

  return undefined
}

/**
 * Helper: Map component category to Maya's expected category
 */
function mapComponentCategoryToMayaCategory(category: string): string {
  // Map component categories to Maya's expected categories
  const mapping: Record<string, string> = {
    'alo-workout': 'Full Body',
    'chanel-luxury': 'Half Body',
    'travel-lifestyle': 'Lifestyle',
    'beauty': 'Close-Up',
    'selfies': 'Close-Up',
    'lifestyle-wellness': 'Lifestyle',
    'seasonal-christmas': 'Lifestyle',
    'tech': 'Lifestyle',
  }

  return mapping[category] || 'Lifestyle'
}

export async function POST(req: NextRequest) {
  try {
    

    // Authenticate user
    const supabase = await createServerClient()
    const { user: authUser, error: authError } = await getAuthenticatedUser()

    if (authError || !authUser) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    // Get effective user (impersonated if admin is impersonating)
    const { getEffectiveNeonUser } = await import("@/lib/simple-impersonation")
    const effectiveUser = await getEffectiveNeonUser(authUser.id)
    if (!effectiveUser) {
      return NextResponse.json({ error: "User not found" }, { status: 404 })
    }

    // Parse request body
    const body = await req.json()
    const {
      userRequest,
      aesthetic,
      context,
      userModifications,
      count = 6, // Changed default from 3 to 6, Maya can override
      referenceImageUrl,
      referenceImages, // NEW: Structured images from upload module { selfies, products, styleRefs, userDescription } - type: ReferenceImages
      customSettings,
      mode = "concept",
      conversationContext,
      studioProMode = false, // Studio Pro mode flag - uses Nano Banana prompting instead of Flux
      enhancedAuthenticity = false, // Enhanced authenticity toggle - only for Classic mode
      guidePrompt, // NEW: Guide prompt from user (for concept #1, then variations for 2-6)
      templateExamples: providedTemplateExamples, // NEW: Pre-loaded template examples from admin prompt builder
      consistencyMode = 'variety', // Consistency mode: 'variety' (default) or 'consistent' (for video editing)
      aspectRatio = "1:1", // Aspect ratio for image generation (default to 1:1)
    } = body

    // ðŸ”´ CRITICAL: Auto-detect detailed prompts as guide prompts if not explicitly provided
    // If user provides a detailed prompt (100+ chars with specific details), treat it as a guide prompt
    // PRIORITY: userRequest > guidePrompt (explicit) > conversationContext (old)
    let detectedGuidePrompt: string | null = null
    let hasNewUserRequest = false
    
    // First, check if userRequest should be the guide prompt (highest priority)
    if (userRequest) {
      const userRequestLength = userRequest.trim().length
      // Check if it's a detailed prompt (has specific details like outfit, location, pose, lighting, camera specs)
      const hasDetailedElements = /(?:wearing|outfit|dressed|seated|standing|sitting|holding|hair|bun|expression|lighting|light|50mm|85mm|lens|f\/|depth of field|skin texture|pores|setting|scene|location|background|tree|fireplace|sofa|room)/i.test(userRequest)
      const hasMultipleSentences = (userRequest.match(/[.!?]\s+/g) || []).length >= 2
      const hasSpecificDetails = userRequestLength > 100 && (hasDetailedElements || hasMultipleSentences)
      
      if (hasSpecificDetails) {
        detectedGuidePrompt = userRequest.trim()
        hasNewUserRequest = true
      } else if (userRequestLength > 20) {
        // User provided a substantial request (even if not detailed enough for guide prompt)
        // This indicates they want something NEW, not to continue with old guide prompt
        hasNewUserRequest = true
      }
    }
    
    // Second, use explicitly provided guidePrompt if no userRequest guide prompt was detected
    if (!detectedGuidePrompt && guidePrompt) {
      detectedGuidePrompt = guidePrompt
    }
    
    // ðŸ”´ CRITICAL: Only extract guide prompt from conversationContext if:
    // 1. No new userRequest was provided, OR
    // 2. The userRequest is a continuation/refinement of the old guide prompt (mentions similar elements)
    // This prevents old guide prompts from persisting when user asks for something different
    if (!detectedGuidePrompt && conversationContext && !hasNewUserRequest) {
      const guidePromptMatch = conversationContext.match(/\[GUIDE_PROMPT_TEXT:\s*([^\]]+)\]/i)
      if (guidePromptMatch && guidePromptMatch[1]) {
        detectedGuidePrompt = guidePromptMatch[1].trim()
      }
    } else if (conversationContext && hasNewUserRequest && !detectedGuidePrompt) {
      // User provided new request - check if they're asking to continue/refine the old guide prompt
      const guidePromptMatch = conversationContext.match(/\[GUIDE_PROMPT_TEXT:\s*([^\]]+)\]/i)
      if (guidePromptMatch && guidePromptMatch[1]) {
        const oldGuidePrompt = guidePromptMatch[1].trim()
        // Check if new request is a continuation/refinement (mentions similar elements)
        const userRequestLower = (userRequest || "").toLowerCase()
        const oldGuideLower = oldGuidePrompt.toLowerCase()
        
        // Extract key elements from old guide prompt
        const oldHasOutfit = /(?:wearing|outfit|dress|sweater|pajamas|gloves|heels)/i.test(oldGuidePrompt)
        const oldHasLocation = /(?:tree|sofa|fireplace|room|setting|scene|location|background)/i.test(oldGuidePrompt)
        const newMentionsOutfit = oldHasOutfit && /(?:wearing|outfit|dress|sweater|pajamas|gloves|heels)/i.test(userRequest || "")
        const newMentionsLocation = oldHasLocation && /(?:tree|sofa|fireplace|room|setting|scene|location|background)/i.test(userRequest || "")
        
        // If new request mentions similar elements, it might be a refinement - use old guide prompt
        // Otherwise, treat it as a NEW request and don't use old guide prompt
        if (newMentionsOutfit || newMentionsLocation) {
          detectedGuidePrompt = oldGuidePrompt
        } else {
        }
      }
    }

    // Log userRequest to debug context loss

    // Get user data
    let userGender = "person"
    let userEthnicity = null
    let physicalPreferences = null
    const { neon } = await import("@neondatabase/serverless")
    const sql = neon(process.env.DATABASE_URL!)

    const userDataResult = await sql`
      SELECT u.gender, u.ethnicity, um.trigger_word, upb.physical_preferences
      FROM users u
      LEFT JOIN user_models um ON u.id = um.user_id 
        AND um.training_status = 'completed'
        AND (um.is_test = false OR um.is_test IS NULL)
      LEFT JOIN user_personal_brand upb ON u.id = upb.user_id
      WHERE u.id = ${effectiveUser.id} 
      LIMIT 1
    `

    if (userDataResult.length > 0 && userDataResult[0].gender) {
      const dbGender = userDataResult[0].gender.toLowerCase().trim()

      if (dbGender === "woman" || dbGender === "female") {
        userGender = "woman"
      } else if (dbGender === "man" || dbGender === "male") {
        userGender = "man"
      } else if (dbGender === "non-binary" || dbGender === "nonbinary" || dbGender === "non binary") {
        userGender = "person"
      } else {
        userGender = dbGender
      }
    }

    userEthnicity = userDataResult[0]?.ethnicity || null
    physicalPreferences = userDataResult[0]?.physical_preferences || null

    const triggerWord = userDataResult[0]?.trigger_word || `user${effectiveUser.id}`

    // ðŸ”´ CRITICAL: Fashion intelligence is ONLY for classic mode (Flux/iPhone/trigger words)
    // In Studio Pro mode, we use Nano Banana with professional photography - fashion intelligence would interfere
    // Fashion intelligence contains FLUX-specific rules, trigger word instructions, and iPhone specs
    // These are NOT appropriate for Studio Pro mode which uses professional photography and brand scenes
    const fashionIntelligence = studioProMode 
      ? "" // Skip fashion intelligence in pro mode - it's designed for classic mode only
      : getFashionIntelligencePrinciples(userGender, userEthnicity)

    // Analyze images if provided (NEW: supports multiple images from upload module)
    let imageAnalysis = ""
    let allImages: string[] = []
    
    // Collect all images from upload module structure
    if (referenceImages) {
      allImages = [
        ...(referenceImages.selfies || []),
        ...(referenceImages.products || []),
        ...(referenceImages.styleRefs || []),
      ]
    }

    // Analyze all images if provided
    if (allImages.length > 0) {
      const visionAnalysisPrompt = referenceImages
        ? `Analyze these images carefully. The user has provided:
${referenceImages.selfies?.length ? `- ${referenceImages.selfies.length} photo(s) of themselves` : ''}
${referenceImages.products?.length ? `- ${referenceImages.products.length} product image(s)` : ''}
${referenceImages.styleRefs?.length ? `- ${referenceImages.styleRefs.length} style reference image(s)` : ''}
${referenceImages.userDescription ? `\nUser's description: "${referenceImages.userDescription}"` : ''}

Tell me everything I need to know to create perfect concepts that incorporate these images naturally.

CRITICAL - DETECT THESE FIRST:
1. **Is this BLACK & WHITE or MONOCHROME?** - If yes, this MUST be in the prompt as "black and white" or "monochrome"
2. **Is this a STUDIO shot?** - Look for: studio lighting, professional setup, clean backgrounds, controlled environment
3. **Is this EDITORIAL/HIGH-FASHION?** - Look for: magazine-style, high-end fashion, dramatic, professional photography
4. **Camera type** - Is this clearly shot on a professional camera (not phone)? Look for: sharp focus, professional quality, studio equipment

Then focus on:
5. **The person's characteristics** - Physical features, style, presence (from selfie photos)
6. **Products** - What products are shown? How should they be featured? (from product images)
7. **Style references** - What aesthetic, mood, lighting, setting should be recreated? (from style reference images)
8. **How images work together** - How should these elements combine in the final concepts?
9. **The outfit/styling** - What are they wearing? Be super specific (fabrics, fit, colors, style)
10. **The pose** - How should they pose? What are their hands doing?
11. **The setting** - Where should this be? What's the vibe of the location?
12. **The lighting** - What kind of light? (studio lighting, natural window light, dramatic side lighting, soft diffused, etc.)
13. **The mood** - What feeling should this give off? (confident, relaxed, mysterious, playful, etc.)
14. **Color palette** - What colors dominate? (If B&W, explicitly say "black and white" or "monochrome")

${referenceImages.userDescription ? `\n**USER'S SPECIFIC INSTRUCTIONS:** "${referenceImages.userDescription}"\nIncorporate this guidance naturally into the analysis.` : ''}

IMPORTANT: If you detect B&W, studio, or editorial - these are MANDATORY requirements that MUST be in every prompt. Don't suggest "natural iPhone photos" if this is clearly a professional studio shot.

Keep it conversational and specific. I need to recreate this EXACT vibe incorporating all these elements.`
        : `Look at this image carefully and tell me everything I need to know to recreate this EXACT vibe.

CRITICAL - DETECT THESE FIRST:
1. **Is this BLACK & WHITE or MONOCHROME?** - If yes, this MUST be in the prompt as "black and white" or "monochrome"
2. **Is this a STUDIO shot?** - Look for: studio lighting, professional setup, clean backgrounds, controlled environment
3. **Is this EDITORIAL/HIGH-FASHION?** - Look for: magazine-style, high-end fashion, dramatic, professional photography
4. **Camera type** - Is this clearly shot on a professional camera (not phone)? Look for: sharp focus, professional quality, studio equipment

Then focus on:
5. **The outfit** - What are they wearing? Be super specific (fabrics, fit, colors, style)
6. **The pose** - How are they standing/sitting? What are their hands doing?
7. **The setting** - Where is this? What's the vibe of the location?
8. **The lighting** - What kind of light is this? (studio lighting, natural window light, dramatic side lighting, soft diffused, etc.)
9. **The mood** - What feeling does this give off? (confident, relaxed, mysterious, playful, etc.)
10. **Color palette** - What colors dominate? (If B&W, explicitly say "black and white" or "monochrome")

IMPORTANT: If you detect B&W, studio, or editorial - these are MANDATORY requirements that MUST be in every prompt. Don't suggest "natural iPhone photos" if this is clearly a professional studio shot.

Keep it conversational and specific. I need to recreate this EXACT vibe.`

      // Build content array with text and all images
      const content: any[] = [
        {
          type: "text",
          text: visionAnalysisPrompt,
        },
      ]

      // Add all images (Claude can handle multiple images)
      allImages.forEach((imageUrl) => {
        content.push({
          type: "image",
          image: imageUrl,
        })
      })

      const { text: visionText } = await generateText({
        model: "anthropic/claude-sonnet-4-20250514",
        messages: [
          {
            role: "user",
            content,
          },
        ],
        temperature: 0.7,
      })

      imageAnalysis = visionText
      
      // ðŸ”´ CRITICAL: Log if hair information is detected in image analysis
      if (imageAnalysis && /hair|hairstyle|hair color|hair length/i.test(imageAnalysis)) {
        const hairInfo = imageAnalysis.match(/(?:hair|hairstyle)[^.]*?([^.]{20,150})/i)
        if (hairInfo) {
        }
      }
    }

    // Generate photoshoot seed if needed
    let photoshootBaseSeed: number | null = null
    if (mode === "photoshoot") {
      photoshootBaseSeed = Math.floor(Math.random() * 1000000)
    }

    const lifestyleContext = getLifestyleContextIntelligence(userRequest || aesthetic || "")

    // ðŸ”´ CRITICAL: Extract concept prompt if user selected a specific concept
    // BUT: User's explicit requests in chat override the pre-selected concept
    let conceptPromptText = ""
    let selectedConceptCategory = ""
    let selectedConceptValue = ""
    let shouldPrioritizeUserRequest = false
    
    // ðŸ”´ CRITICAL: Only extract concept from referenceImages if user hasn't provided a NEW request
    // If user provides a new request (hasNewUserRequest), prioritize their request over pre-selected concept
    if (referenceImages && (referenceImages as any).category && (referenceImages as any).concept && !hasNewUserRequest) {
      selectedConceptCategory = (referenceImages as any).category
      selectedConceptValue = (referenceImages as any).concept
      const conceptPrompt = getConceptPrompt(selectedConceptCategory, selectedConceptValue)
      if (conceptPrompt) {
        conceptPromptText = conceptPrompt
      }
    } else if (hasNewUserRequest && referenceImages && (referenceImages as any).category && (referenceImages as any).concept) {
      // User provided new request - check if it's related to the selected concept or something different
      selectedConceptCategory = (referenceImages as any).category
      selectedConceptValue = (referenceImages as any).concept
      const conceptPrompt = getConceptPrompt(selectedConceptCategory, selectedConceptValue)
      if (conceptPrompt) {
        conceptPromptText = conceptPrompt
      }
    }
    
    // ðŸ”´ CRITICAL: Check if user is explicitly requesting something different from the selected concept
    // Also check if user wants something different from old guide prompt
    const userRequestLower = (userRequest || "").toLowerCase().trim()
    const conversationContextLower = (conversationContext || "").toLowerCase().trim()
    const combinedUserRequest = `${userRequestLower} ${conversationContextLower}`.toLowerCase()
    
    // Determine if user wants something different:
    // 1. User explicitly says "different", "change", "instead", "not", etc.
    // CRITICAL: Only check userRequestLower, not combinedUserRequest, to detect NEW requests
    const explicitDifferentKeywords = /different|change|instead|not|no.*want|prefer|rather|switch|new.*concept|another|other|actually|make it|i want|create.*for/i.test(userRequestLower)
    
    // 2. User provides a substantial request that doesn't align with the selected concept
    const hasSubstantialRequest = userRequest && userRequest.trim().length > 10
    
    // 3. User's request doesn't mention the selected concept or category keywords
    const conceptValueLower = selectedConceptValue?.toLowerCase() || ""
    const conceptCategoryLower = selectedConceptCategory?.toLowerCase() || ""
    const mentionsSelectedConcept = conceptValueLower && combinedUserRequest.includes(conceptValueLower)
    const mentionsSelectedCategory = conceptCategoryLower && combinedUserRequest.includes(conceptCategoryLower)
    
    // Prioritize user request if:
    // - They explicitly say they want something different, OR
    // - They provide a substantial request that doesn't mention the selected concept/category
    shouldPrioritizeUserRequest = explicitDifferentKeywords || 
      (hasSubstantialRequest && !mentionsSelectedConcept && !mentionsSelectedCategory)
    
    if (shouldPrioritizeUserRequest) {
    }
    
    // âœ… Use provided templates if available (from admin prompt builder) - these are optional examples for inspiration
    let templateExamples: string[] = Array.isArray(providedTemplateExamples) ? providedTemplateExamples : []
    
    if (templateExamples.length > 0) {
    }

    // PRIORITY 1 FIX #3: Make Scandinavian filter conditional - default but allow override
    // Check if user specified a different aesthetic (before trend research)
    const userAestheticLower = (aesthetic || "").toLowerCase()
    // userRequestLower already declared above, reuse it
    const combinedStyle = userAestheticLower + " " + userRequestLower
    const wantsScandinavian = /scandi|scandinavian|minimal|minimalist|nordic|hygge/i.test(combinedStyle)
    const wantsNonScandi = /vintage|y2k|dark.?academia|maximalist|mob.?wife|bold|colorful|vibrant|editorial|high.?fashion/i.test(combinedStyle) && !wantsScandinavian

    // ðŸ”´ CRITICAL: Skip trend research in Studio Pro mode when guide prompt is active
    // Guide prompts are explicit user instructions that should not be overridden by trend research
    // Also, trend research defaults to Scandinavian minimalism which could conflict with guide prompts
    let trendResearch = ""
    if (!detectedGuidePrompt && (!aesthetic || aesthetic.toLowerCase().includes("instagram") || aesthetic.toLowerCase().includes("trend"))) {

      // Build trend research prompt with conditional Scandinavian filter
      let trendResearchPrompt = `Research current Instagram fashion trends for personal brand content creators. Focus on:

1. What aesthetics are performing well RIGHT NOW on Instagram (Jan 2025)
2. Color palettes that are trending for fashion content
3. Outfit styling that's getting high engagement
4. Settings and locations that feel current

Keep it brief (2-3 paragraphs) and actionable for a fashion photographer creating content.`

      // Add conditional filter instruction
      // BUT: Skip Scandinavian default if guide prompt is active (guide prompt takes priority)
      if (detectedGuidePrompt) {
        // Guide prompt is active - don't apply Scandinavian filter, let guide prompt dictate the aesthetic
        trendResearchPrompt += `\n\nCRITICAL: The user has provided an exact guide prompt. Use these trends as general inspiration only - DO NOT override the guide prompt's aesthetic, colors, or styling choices.`
      } else if (wantsNonScandi) {
        const aestheticName = userAestheticLower || "the requested"
        trendResearchPrompt += `\n\nCRITICAL: Filter trends through ${aestheticName} aesthetic lens.`
      } else {
        // Default: Scandinavian minimalism (beautiful default aesthetic)
        // BUT: Only if no guide prompt is active
        trendResearchPrompt += `\n\nCRITICAL: Filter trends through a SCANDINAVIAN MINIMALISM lens - we want Nordic-appropriate trends only (natural tones, clean lines, quality fabrics).`
      }

      const { text: researchText } = await generateText({
        model: "anthropic/claude-sonnet-4-20250514",
        messages: [
          {
            role: "user",
            content: trendResearchPrompt,
          },
        ],
        temperature: 0.7,
      })

      trendResearch = researchText
    }

    let trendFilterInstruction = ""
    if (trendResearch) {
      // ðŸ”´ CRITICAL: If guide prompt is active, don't apply Scandinavian defaults
      // Guide prompts are explicit user instructions that take absolute priority
      if (detectedGuidePrompt) {
        // Guide prompt is active - use trends as inspiration only, don't override guide prompt
        trendFilterInstruction = `Use these trends as general inspiration only. The guide prompt's aesthetic, colors, and styling take absolute priority - do not filter or modify them.`
      } else if (wantsNonScandi) {
        // User explicitly wants non-Scandinavian aesthetic - respect their choice
        const aestheticName = userAestheticLower || "the requested"
        trendFilterInstruction = `Use these insights to inform your concept creation, filtered through ${aestheticName} aesthetic.`
      } else if (wantsScandinavian) {
        // User explicitly wants Scandinavian - apply filter
        trendFilterInstruction = `Use these insights to inform your concept creation, filtered through Scandinavian minimalism (natural tones, clean lines, quality).`
      } else {
        // Default: Scandinavian minimalism (beautiful default aesthetic)
        // BUT: Only if no guide prompt is active
        trendFilterInstruction = `Use these insights to inform your concept creation, but ALWAYS filter through Scandinavian minimalism (natural tones, clean lines, quality) as the default aesthetic.`
      }
    }

    const conversationContextSection = conversationContext
      ? `
=== CONVERSATION CONTEXT ===
Here's what we've been discussing. Use this to understand what the user wants MORE of or to continue the creative direction:

${conversationContext}

IMPORTANT: 
- If the user says "more of this", "similar to before", "like the last ones" - create variations on the themes/styles discussed above
- If previous concepts were about a specific aesthetic (G-Wagon, moody, editorial, etc.) - continue with that vibe
- Reference what Maya described in her previous responses for styling continuity
===
`
      : ""

    // CRITICAL: Detect workflow type in Studio Pro mode
    let workflowType: string | null = null
    let isCarouselRequest = false
    let slideCount: number | null = null
    
    if (studioProMode) {
      try {
        const { detectStudioProIntent } = await import("@/lib/maya/studio-pro-system-prompt")
        // userRequestLower already declared above, reuse it
        const conversationContextLower = (conversationContext || "").toLowerCase()
        const combinedRequest = `${userRequest || ""} ${conversationContext || ""}`.toLowerCase()
        
        // Detect workflow type using the same logic as Maya chat
        const workflowIntent = detectStudioProIntent(combinedRequest)
        workflowType = workflowIntent.mode || null
        
        // Legacy carousel detection (for backward compatibility)
        isCarouselRequest = workflowType === "carousel-slides" ||
          /carousel|multi.*slide|multiple.*slide|slide.*post|carousel.*post|multi.*image|several.*slide/i.test(userRequestLower) ||
          /carousel|multi.*slide|multiple.*slide/i.test(conversationContextLower)
        
        slideCount = isCarouselRequest 
          ? (() => {
              // Extract slide count from various patterns, handling 0 as a valid value
              const slideMatch = userRequestLower.match(/(\d+)\s*(?:slide|page)/i)?.[1]
              const partMatch = userRequestLower.match(/(\d+)\s*(?:part|step)/i)?.[1]
              const imageMatch = userRequestLower.match(/(\d+)\s*(?:image|photo)/i)?.[1]
              
              // Try each pattern, using nullish coalescing to handle 0 correctly
              const slideNum = slideMatch != null ? parseInt(slideMatch, 10) : null
              const partNum = partMatch != null ? parseInt(partMatch, 10) : null
              const imageNum = imageMatch != null ? parseInt(imageMatch, 10) : null
              
              // Return first valid number (not null and not NaN), or default to 5
              return (slideNum != null && !isNaN(slideNum)) ? slideNum :
                     (partNum != null && !isNaN(partNum)) ? partNum :
                     (imageNum != null && !isNaN(imageNum)) ? imageNum :
                     5
            })()
          : null
      } catch (importError) {
        console.error("[v0] Error importing detectStudioProIntent:", importError)
        // Fallback to basic carousel detection
        isCarouselRequest = /carousel|multi.*slide|multiple.*slide|slide.*post|carousel.*post|multi.*image|several.*slide/i.test(userRequestLower) ||
          /carousel|multi.*slide|multiple.*slide/i.test((conversationContext || "").toLowerCase())
        
        // Fallback: use default of 5 slides if carousel detected but no count specified
        slideCount = isCarouselRequest ? 5 : null
      }
    }
    
      // Map upload module categories directly to detected categories
      const uploadCategoryLower = uploadModuleCategoryForAI.toLowerCase()
      
      if (uploadCategoryLower.includes('workout') || uploadCategoryLower.includes('athletic') || uploadCategoryLower.includes('fitness') || uploadCategoryLower === 'gym' || uploadCategoryLower === 'brand-content' || uploadCategoryLower === 'wellness-content') {
        detectedCategory = 'alo-workout'
      } else if (uploadCategoryLower.includes('travel') || uploadCategoryLower === 'airport' || uploadCategoryLower === 'travel-lifestyle' || uploadCategoryLower === 'luxury-travel') {
        detectedCategory = 'travel-airport'
      } else if (uploadCategoryLower.includes('luxury') || uploadCategoryLower.includes('fashion') || uploadCategoryLower === 'fashion-editorial') {
        detectedCategory = 'luxury-fashion'
      } else if (uploadCategoryLower.includes('cozy') || uploadCategoryLower === 'home' || uploadCategoryLower.includes('christmas') || uploadCategoryLower.includes('holiday') || uploadCategoryLower === 'seasonal-holiday') {
        detectedCategory = uploadCategoryLower.includes('christmas') || uploadCategoryLower.includes('holiday') || uploadCategoryLower === 'seasonal-holiday' ? 'seasonal-christmas' : 'casual-lifestyle'
      } else if (uploadCategoryLower === 'casual' || uploadCategoryLower === 'lifestyle' || uploadCategoryLower === 'coffee') {
        detectedCategory = 'casual-lifestyle'
      } else if (uploadCategoryLower === 'street' || uploadCategoryLower === 'street-style') {
        detectedCategory = 'luxury-fashion'
      } else if (uploadCategoryLower.includes('beauty') || uploadCategoryLower === 'beauty-self-care' || uploadCategoryLower === 'selfie-styles') {
        // Beauty categories - use AI generation system (not prompt constructor)
        detectedCategory = 'casual-lifestyle' // Fallback, but will use AI generation
      } else if (uploadCategoryLower === 'tech-work' || uploadCategoryLower === 'tech') {
        // Tech categories - use AI generation system
        detectedCategory = 'casual-lifestyle' // Fallback, but will use AI generation
      } else {
        // If upload module category doesn't match known categories, use pattern matching
        detectedCategory = detectCategoryFromRequest(enrichedUserRequestForDetection, aesthetic, context, conversationContext)
      }
    } else {
      // User provided a request OR no upload module category - prioritize user request
      if (hasUserRequestForAI) {
      } else {
      }
      detectedCategory = detectCategoryFromRequest(enrichedUserRequestForDetection, aesthetic, context, conversationContext)
      
      // ðŸ”´ FIX: If no category detected and upload module category exists, use it as fallback
      if (!detectedCategory && uploadModuleCategoryForAI) {
        const uploadCategoryLower = uploadModuleCategoryForAI.toLowerCase()
        if (uploadCategoryLower.includes('workout') || uploadCategoryLower.includes('athletic') || uploadCategoryLower.includes('fitness') || uploadCategoryLower === 'gym' || uploadCategoryLower === 'brand-content' || uploadCategoryLower === 'wellness-content') {
          detectedCategory = 'alo-workout'
        } else if (uploadCategoryLower.includes('travel') || uploadCategoryLower === 'airport' || uploadCategoryLower === 'travel-lifestyle' || uploadCategoryLower === 'luxury-travel') {
          detectedCategory = 'travel-airport'
        } else if (uploadCategoryLower.includes('luxury') || uploadCategoryLower.includes('fashion') || uploadCategoryLower === 'fashion-editorial') {
          detectedCategory = 'luxury-fashion'
        } else if (uploadCategoryLower.includes('cozy') || uploadCategoryLower === 'home' || uploadCategoryLower.includes('christmas') || uploadCategoryLower.includes('holiday') || uploadCategoryLower === 'seasonal-holiday') {
          detectedCategory = uploadCategoryLower.includes('christmas') || uploadCategoryLower.includes('holiday') || uploadCategoryLower === 'seasonal-holiday' ? 'seasonal-christmas' : 'casual-lifestyle'
        } else if (uploadCategoryLower === 'casual' || uploadCategoryLower === 'lifestyle' || uploadCategoryLower === 'coffee') {
          detectedCategory = 'casual-lifestyle'
        } else if (uploadCategoryLower === 'street' || uploadCategoryLower === 'street-style') {
          detectedCategory = 'luxury-fashion'
        }
      }
      
      // ðŸ”´ FIX: If no category detected, allow dynamic generation instead of defaulting
      // Maya should use her full fashion knowledge when category is unknown
      if (!detectedCategory || detectedCategory.trim().length === 0) {
        const hasAnyText = enrichedUserRequestForDetection.trim().length > 0
        if (hasAnyText) {
          // User provided text but no category matched - this is likely an aesthetic description
          // Allow Maya to use her full fashion knowledge dynamically
          detectedCategory = null // Set to null to trigger dynamic generation path
        } else if (uploadModuleCategoryForAI) {
          // No text but upload module category exists - use it
          // This should have been handled above, but if not, we'll use AI generation with upload category context
          detectedCategory = null
        } else {
          // No text and no upload category - use AI generation with full Maya knowledge
          detectedCategory = null
        }
      }
    }
    
    const detectedBrandValue = detectBrand(enrichedUserRequestForDetection || aesthetic || context)

    
    // Log if category is null (will use dynamic generation)
    if (!detectedCategory && enrichedUserRequestForDetection && enrichedUserRequestForDetection.trim().length > 0) {
    }
    
    // Special logging for Christmas requests
    if (detectedCategory === 'seasonal-christmas') {
    }

    // Week 2 Task 2: Generate concepts with validation, retry logic, and prompt caching

    const MAX_RETRIES = 2
    let concepts: MayaConcept[] = []
    let attempts = 0
    let lastError: string | null = null
    let retryPrompt = conceptPrompt // Use mutable variable for retry attempts

    while (attempts <= MAX_RETRIES && concepts.length !== count) {
      attempts++
      
      if (attempts > 1) {
      }

      try {
        // Week 2 Optimization: Use direct Anthropic API with prompt caching
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-API-Key': process.env.ANTHROPIC_API_KEY!,
            'anthropic-version': '2023-06-01',
            'anthropic-beta': 'prompt-caching-2024-07-31',
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 4000, // Enough for multiple concepts
            system: [
              {
                type: 'text',
                text: mayaPersonalitySection,
                cache_control: { type: 'ephemeral' }
              }
            ],
            messages: [
              {
                role: 'user',
                content: retryPrompt,
              },
            ],
            temperature: 0.85,
          })
        })

        if (!response.ok) {
          const errorText = await response.text()
          throw new Error(`Anthropic API error: ${response.status} - ${errorText}`)
        }

        const data = await response.json()

        // Log cache usage
        let cacheReadTokens = 0
        if (data.usage) {
          cacheReadTokens = data.usage.cache_read_input_tokens || 0

        // Parse JSON response
        const jsonMatch = text.match(/\[[\s\S]*\]/)
        if (jsonMatch) {
          concepts = JSON.parse(jsonMatch[0])
          
          
          // Week 2 Task 2: Validate concept count
          if (concepts.length === count) {
            break // Success - exit retry loop
          } else {
            console.warn(`[v0] [AI-GENERATION] âš ï¸ Concept count mismatch: expected ${count}, got ${concepts.length}`)
            if (attempts <= MAX_RETRIES) {
              // Add retry instruction to prompt for next attempt
              retryPrompt = `${conceptPrompt}\n\n**CRITICAL: You must generate EXACTLY ${count} concepts. You generated ${concepts.length} concepts, which is incorrect. Please generate exactly ${count} concepts.`
              // Wait before retry (exponential backoff)
              const waitTime = attempts * 1000 // 1s, 2s
              await new Promise(resolve => setTimeout(resolve, waitTime))
              continue // Retry
            }
          }
        } else {
          console.error('[v0] [AI-GENERATION] âŒ Failed to parse JSON from AI response')
          lastError = 'Failed to parse JSON response'
          if (attempts <= MAX_RETRIES) {
            continue // Retry
          }
        }
      } catch (error: any) {
        console.error(`[v0] [AI-GENERATION] âŒ Error on attempt ${attempts}:`, error.message)
        lastError = error.message
        if (attempts <= MAX_RETRIES) {
          // Wait before retry (exponential backoff)
          const waitTime = attempts * 1000 // 1s, 2s
          await new Promise(resolve => setTimeout(resolve, waitTime))
          continue
        }
      }
    }

    // Week 2 Task 2: Fallback if retries failed
    if (concepts.length !== count && concepts.length > 0) {
      console.warn(`[v0] [AI-GENERATION] âš ï¸ After ${attempts} attempts, got ${concepts.length} concepts (expected ${count}). Using available concepts.`)
      // Use what we have - better than nothing
    } else if (concepts.length === 0) {
      console.error(`[v0] [AI-GENERATION] âŒ Failed to generate concepts after ${attempts} attempts. Last error: ${lastError}`)
      // Return empty array - will be handled by caller
    }

    // ðŸ”´ CRITICAL: Check for upload module category - some categories (beauty, tech, selfies) don't use prompt constructor
    const uploadModuleCategory = (referenceImages as any)?.category
    const uploadModuleConcept = (referenceImages as any)?.concept
    const unsupportedCategories = ['beauty', 'tech', 'selfies', 'beauty-self-care', 'selfie-styles', 'tech-work']
    const isUnsupportedCategory = uploadModuleCategory && 
      unsupportedCategories.some(unsupported => uploadModuleCategory.toLowerCase().includes(unsupported.toLowerCase()))
    
        // Map upload module category directly to prompt constructor categories
        const uploadCategoryLower = uploadModuleCategory.toLowerCase()
        
        // Direct mapping from upload module categories to prompt constructor categories
        // Check compound categories first (e.g., "beauty-self-care", "travel-lifestyle")
        if (uploadCategoryLower.includes('workout') || uploadCategoryLower.includes('athletic') || uploadCategoryLower.includes('fitness') || uploadCategoryLower === 'gym' || uploadCategoryLower === 'brand-content' || uploadCategoryLower === 'wellness-content') {
          category = 'workout'
          vibe = 'athletic'
          location = 'gym'
          detectedCategoryForMapping = 'alo-workout'
        } else if (uploadCategoryLower.includes('travel') || uploadCategoryLower === 'airport' || uploadCategoryLower === 'travel-lifestyle' || uploadCategoryLower === 'luxury-travel') {
          category = 'travel'
          vibe = 'travel'
          location = 'airport'
          detectedCategoryForMapping = 'travel-airport'
        } else if (uploadCategoryLower.includes('luxury') || uploadCategoryLower.includes('fashion') || uploadCategoryLower === 'fashion-editorial') {
          category = 'luxury'
          vibe = 'luxury'
          location = 'luxury location'
          detectedCategoryForMapping = 'luxury-fashion'
        } else if (uploadCategoryLower.includes('cozy') || uploadCategoryLower === 'home' || uploadCategoryLower.includes('christmas') || uploadCategoryLower.includes('holiday') || uploadCategoryLower === 'seasonal-holiday') {
          category = 'cozy'
          vibe = 'cozy'
          location = 'home'
          detectedCategoryForMapping = uploadCategoryLower.includes('christmas') || uploadCategoryLower.includes('holiday') || uploadCategoryLower === 'seasonal-holiday' ? 'seasonal-christmas' : 'casual-lifestyle'
        } else if (uploadCategoryLower === 'casual' || uploadCategoryLower === 'lifestyle' || uploadCategoryLower === 'coffee') {
          category = 'casual'
          vibe = 'casual'
          location = 'coffee-shop'
          detectedCategoryForMapping = 'casual-lifestyle'
        } else if (uploadCategoryLower === 'street' || uploadCategoryLower === 'street-style') {
          category = 'street-style'
          vibe = 'street-style'
          location = 'street'
          detectedCategoryForMapping = 'luxury-fashion'
        } else if (uploadCategoryLower.includes('beauty') || uploadCategoryLower === 'beauty-self-care' || uploadCategoryLower === 'selfie-styles') {
          // Beauty categories don't use prompt constructor (they're in unsupportedCategories)
          // But we should still log and handle them
          category = 'casual' // Fallback for now
          vibe = 'casual'
          location = 'street'
          detectedCategoryForMapping = 'casual-lifestyle'
        } else if (uploadCategoryLower === 'tech-work' || uploadCategoryLower === 'tech') {
          // Tech categories don't use prompt constructor
          category = 'casual' // Fallback for now
          vibe = 'casual'
          location = 'street'
          detectedCategoryForMapping = 'casual-lifestyle'
        } else {
          // If upload module category doesn't match known categories, enrich request and use pattern matching
          const requestWithUploadContext = uploadModuleConcept
            ? `${enrichedUserRequest} ${uploadModuleCategory} ${uploadModuleConcept}`.trim()
            : `${enrichedUserRequest} ${uploadModuleCategory}`.trim()
          
          const detected = detectCategoryForPromptConstructor(requestWithUploadContext, aesthetic, context, conversationContext)
          category = detected.category
          vibe = detected.vibe
          location = detected.location
          detectedCategoryForMapping = detectCategoryFromRequest(requestWithUploadContext, aesthetic, context, conversationContext)
        }
      } else {
        // User provided a request OR no upload module category - prioritize user request
        if (hasUserRequest) {
        } else {
        }
        const requestWithUploadContext = enrichedUserRequest
        const detected = detectCategoryForPromptConstructor(requestWithUploadContext, aesthetic, context, conversationContext)
        
        // ðŸ”´ FIX: Check if category was actually detected (not defaulted)
        categoryWasDetected = detected.wasDetected
        
        if (categoryWasDetected) {
          // Category was successfully detected from patterns
          category = detected.category
          vibe = detected.vibe
          location = detected.location
        } else {
          // Category was NOT detected - this is likely an aesthetic description
          // Allow dynamic generation instead of forcing defaults
          
          // Try detectCategoryFromRequest as fallback, but don't force it
          const detectedFromRequest = detectCategoryFromRequest(requestWithUploadContext, aesthetic, context, conversationContext)
          if (detectedFromRequest && detectedFromRequest.trim().length > 0) {
            detectedCategoryForMapping = detectedFromRequest
            // Map detected category to prompt constructor format
            if (detectedFromRequest === 'alo-workout') {
              category = 'workout'
              vibe = 'athletic'
              location = 'gym'
              categoryWasDetected = true
            } else if (detectedFromRequest === 'travel-airport') {
              category = 'travel'
              vibe = 'travel'
              location = 'airport'
              categoryWasDetected = true
            } else if (detectedFromRequest === 'luxury-fashion') {
              category = 'luxury'
              vibe = 'luxury'
              location = 'luxury location'
              categoryWasDetected = true
            } else if (detectedFromRequest === 'seasonal-christmas') {
              category = 'cozy'
              vibe = 'cozy'
              location = 'home'
              categoryWasDetected = true
            } else if (detectedFromRequest === 'casual-lifestyle') {
              // Only use casual-lifestyle if we have meaningful text
              if (requestWithUploadContext.trim().length > 0) {
                category = 'casual'
                vibe = 'casual'
                location = 'coffee-shop'
                categoryWasDetected = true
              }
            }
            // If detectedFromRequest doesn't map, leave category as null to allow dynamic generation
          }
          
          // If still no category detected and upload module category exists, use it
          if (!categoryWasDetected && uploadModuleCategory) {
            // Map upload module category (same logic as above)
            const uploadCategoryLower = uploadModuleCategory.toLowerCase()
            if (uploadCategoryLower.includes('workout') || uploadCategoryLower.includes('athletic') || uploadCategoryLower.includes('fitness') || uploadCategoryLower === 'gym' || uploadCategoryLower === 'brand-content' || uploadCategoryLower === 'wellness-content') {
              category = 'workout'
              vibe = 'athletic'
              location = 'gym'
              detectedCategoryForMapping = 'alo-workout'
              categoryWasDetected = true
            } else if (uploadCategoryLower.includes('travel') || uploadCategoryLower === 'airport' || uploadCategoryLower === 'travel-lifestyle' || uploadCategoryLower === 'luxury-travel') {
              category = 'travel'
              vibe = 'travel'
              location = 'airport'
              detectedCategoryForMapping = 'travel-airport'
              categoryWasDetected = true
            } else if (uploadCategoryLower.includes('luxury') || uploadCategoryLower.includes('fashion') || uploadCategoryLower === 'fashion-editorial') {
              category = 'luxury'
              vibe = 'luxury'
              location = 'luxury location'
              detectedCategoryForMapping = 'luxury-fashion'
              categoryWasDetected = true
            } else if (uploadCategoryLower.includes('cozy') || uploadCategoryLower === 'home' || uploadCategoryLower.includes('christmas') || uploadCategoryLower.includes('holiday') || uploadCategoryLower === 'seasonal-holiday') {
              category = 'cozy'
              vibe = 'cozy'
              location = 'home'
              detectedCategoryForMapping = uploadCategoryLower.includes('christmas') || uploadCategoryLower.includes('holiday') || uploadCategoryLower === 'seasonal-holiday' ? 'seasonal-christmas' : 'casual-lifestyle'
              categoryWasDetected = true
            } else if (uploadCategoryLower === 'casual' || uploadCategoryLower === 'lifestyle' || uploadCategoryLower === 'coffee') {
              category = 'casual'
              vibe = 'casual'
              location = 'coffee-shop'
              detectedCategoryForMapping = 'casual-lifestyle'
              categoryWasDetected = true
            } else if (uploadCategoryLower === 'street' || uploadCategoryLower === 'street-style') {
              category = 'street-style'
              vibe = 'street-style'
              location = 'street'
              detectedCategoryForMapping = 'luxury-fashion'
              categoryWasDetected = true
            }
          }
        }
        
        // Get detectedCategoryForMapping if not already set
        if (!detectedCategoryForMapping) {
          const detectedFromRequest = detectCategoryFromRequest(requestWithUploadContext, aesthetic, context, conversationContext)
          detectedCategoryForMapping = (detectedFromRequest && detectedFromRequest.trim().length > 0) ? detectedFromRequest : null
        }
        
        // ðŸ”´ FIX: If no category detected, allow dynamic generation instead of forcing defaults
        if (!category || !vibe || !location) {
          if (uploadModuleCategory) {
          } else {
          }
          // Don't force defaults - leave as null to trigger dynamic generation path
          // The AI generation path will use Maya's full fashion knowledge
        }
      }
      
      // ðŸ”´ FIX: If no category detected, skip prompt constructor and use AI generation
      // Don't force defaults - allow dynamic generation with Maya fashion knowledge
      if (!category || !vibe || !location) {
        // Leave category/vibe/location as null - this will skip prompt constructor section below
        // and trigger AI generation path which uses Maya's full fashion knowledge
      }
      
      const mappedCategory = mapCategoryForBrandLibrary(detectedCategoryForMapping, enrichedUserRequest)
      
        
        // Generate prompts using prompt constructor (PRIMARY METHOD)
        const promptConstructorConcepts: MayaConcept[] = []
        let promptConstructorFailed = false
        
        try {
          for (let i = 0; i < count; i++) {
            // ðŸ”´ CRITICAL: Studio Pro Mode (NanoBanana) does NOT use trigger words
            // Instead, it uses the mandatory identity preservation instruction
            // Do not pass triggerWord for Studio Pro Mode
            // ðŸ”´ CRITICAL: Use enriched userRequest that includes conversationContext
            // This preserves context from the conversation thread (like Classic Mode does)
            // ðŸ”´ CRITICAL: Use enhanced prompt constructor for dynamic, detailed prompts
            // This generates longer (150-400 words), more detailed prompts with specific sections
            // Matching production-quality prompts with poses, lighting, environment, makeup, hair, camera specs
            
            // Extract hair info from image analysis for enhanced prompts
            let hairInfoFromAnalysis = ''
            if (imageAnalysis) {
              let hairMatch = imageAnalysis.match(/(?:hair|hairstyle)(?:\s+is|\s+appears|\s+color|\s+length)[^.]*?([^.]{15,120})/i)
              if (!hairMatch) {
                hairMatch = imageAnalysis.match(/(?:long|short|medium|brown|blonde|black|red|auburn|brunette|dark|light)[^.]*?hair[^.]*?([^.]{10,80})/i)
              }
              if (!hairMatch) {
                hairMatch = imageAnalysis.match(/with\s+([^.]*?(?:long|short|medium|brown|blonde|black|red|auburn|brunette)[^.]*?hair[^.]{0,50})/i)
              }
              if (!hairMatch) {
                hairMatch = imageAnalysis.match(/(?:hair|hairstyle)[^.]*?([^.]{20,100})/i)
              }
              
              if (hairMatch && hairMatch[1]) {
                hairInfoFromAnalysis = hairMatch[1].trim()
                  .replace(/\b(the person's|their|they have|showing|visible|appears|looks like|seems to have|has|wearing|styled)\b/gi, '')
                  .replace(/[.,;:]\s*$/, '')
                  .replace(/\s+/g, ' ')
                  .trim()
                
                if (hairInfoFromAnalysis && 
                    /(?:long|short|medium|brown|blonde|black|red|auburn|brunette|dark|light|curly|straight|wavy|hair|hairstyle)/i.test(hairInfoFromAnalysis)) {
                } else {
                  hairInfoFromAnalysis = ''
                }
              }
            }
            
            // Use enhanced prompt constructor for detailed, dynamic prompts
            // Extract user age from physical preferences
            let extractedAge: string | undefined
            if (physicalPreferences) {
              const ageMatch = physicalPreferences.match(/(?:age|aged?|years? old)\s*:?\s*(\d+)/i)
              if (ageMatch) {
                const age = parseInt(ageMatch[1])
                if (age >= 20 && age < 30) extractedAge = 'Woman in late twenties'
                else if (age >= 30 && age < 40) extractedAge = 'Woman in early thirties'
                else if (age >= 40) extractedAge = 'Woman in forties'
              }
            }
            
            const constructedPrompt = buildEnhancedPrompt({
              category: category || 'casual',
              vibe: vibe || 'casual',
              location: location || 'street',
              userAge: extractedAge,
              userFeatures: physicalPreferences,
              userGender: userGender || 'woman',
              hairStyle: hairInfoFromAnalysis || undefined,
              userRequest: enrichedUserRequest || userRequest,
              imageAnalysis: imageAnalysis || undefined,
            })
            
            // Validate the generated prompt (warnings only, not errors)
            const validation = validateProductionPrompt(constructedPrompt)
            if (validation.warnings.length > 0) {
            }
            
            // ðŸ”´ CRITICAL: Use upload module category/concept for titles if available
            // Otherwise fall back to detected category
            let conceptTitle = ''
            let conceptDescription = ''
            
            if (uploadModuleCategory && uploadModuleConcept) {
              // Use upload module category/concept for titles (e.g., "Beauty Concept 1" or "Makeup Look Concept 1")
              const categoryTitle = uploadModuleCategory.charAt(0).toUpperCase() + uploadModuleCategory.slice(1)
              const conceptTitlePart = uploadModuleConcept.charAt(0).toUpperCase() + uploadModuleConcept.slice(1)
              conceptTitle = `${categoryTitle} - ${conceptTitlePart} ${i + 1}`
              conceptDescription = `${uploadModuleCategory} ${uploadModuleConcept} concept with detailed specifications`
            } else {
              // ðŸ”´ FIX: Use best available category source, not just default 'category' variable
              // Priority: detectedCategoryForMapping > category > fallback
              const bestCategory = detectedCategoryForMapping || category || 'casual'
              const bestCategoryTitle = bestCategory === 'alo-workout' ? 'Workout' :
                                       bestCategory === 'travel-airport' ? 'Travel' :
                                       bestCategory === 'luxury-fashion' ? 'Luxury' :
                                       bestCategory === 'seasonal-christmas' ? 'Holiday' :
                                       bestCategory === 'casual-lifestyle' ? 'Casual' :
                                       bestCategory.charAt(0).toUpperCase() + bestCategory.slice(1).replace(/-/g, ' ')
              
              conceptTitle = `${bestCategoryTitle} Concept ${i + 1}`
              conceptDescription = `${vibe || 'casual'} ${category || 'casual'} concept with detailed brand specifications`
              
        } catch (error) {
          console.error('[v0] [PROMPT-CONSTRUCTOR] âŒ Error generating prompts:', error)
          promptConstructorFailed = true
        }
        
        // ðŸŽ¯ FALLBACK: Use Universal Prompts ONLY if prompt constructor failed
        if (promptConstructorFailed || concepts.length === 0) {
          
          // Include conversationContext for better category detection (like Classic Mode)
          const enrichedRequestForFallback = conversationContext 
            ? `${userRequest || ''} ${conversationContext}`.trim()
            : userRequest || ''
          const detectedCategory = detectCategoryFromRequest(enrichedRequestForFallback, aesthetic, context, conversationContext)
          // ðŸ”´ FIX: If detectedCategory is null, skip Universal Prompts and use AI generation
          // ðŸ”´ CRITICAL: Removed 'seasonal-christmas' from fallback - trust Maya's generation for Christmas requests
          const universalPromptCategory = detectedCategory && ['travel-airport', 'alo-workout', 'casual-lifestyle', 'luxury-fashion'].includes(detectedCategory)
            ? detectedCategory
            : (category ? mapToUniversalPromptCategory(category, userRequest) : null)
          
          if (universalPromptCategory) {
            try {
              const fallbackPrompts = getRandomPrompts(universalPromptCategory, count)
              
              if (fallbackPrompts.length > 0) {
                const universalPromptConcepts: MayaConcept[] = fallbackPrompts.map((universalPrompt: UniversalPrompt) => ({
                  title: universalPrompt.title,
                  description: universalPrompt.description,
                  category: mapComponentCategoryToMayaCategory(detectedCategoryForMapping || 'casual-lifestyle'),
                  fashionIntelligence: '',
                  lighting: '',
                  location: location || 'street', // ðŸ”´ FIX: Ensure location is always string, not null
                  prompt: universalPrompt.prompt,
                }))
                
                concepts = universalPromptConcepts
              } else {
                console.warn(`[v0] [UNIVERSAL-PROMPTS] No fallback prompts found for ${universalPromptCategory}`)
              }
            } catch (error) {
              console.error('[v0] [UNIVERSAL-PROMPTS] âŒ Error using fallback prompts:', error)
            }
          } else {
            // No universal prompt category - this means category is null
            // AI generation path will be used (already handled above)
          }
        }
      } else {
      }
    }
    
    // ðŸ”´ REMOVED: Post-generation brand injection that overrides Maya's prompts
    // Maya's generated prompts should stand as-is without any post-processing injection or replacement
    // Brand library instructions in the AI prompt (for Pro Mode) are sufficient guidance

    // ðŸ”´ CRITICAL: If guide prompt is provided (explicit or auto-detected), use it for concept #1 and create variations for 2-6
    if (detectedGuidePrompt && detectedGuidePrompt.trim().length > 0 && concepts.length > 0) {
      
      // Direct generation: let Maya generate unique variations with guide prompt context
      
      // Concept #1: Use guide prompt EXACTLY (but merge with user's image references)
      const guidePromptWithImages = mergeGuidePromptWithImages(detectedGuidePrompt, referenceImages, studioProMode)
      concepts[0].prompt = guidePromptWithImages
      
      // For concepts 2-6, let Maya generate unique variations using her intelligence
      // The prompts will already be unique since they come from Maya's initial generation
      // We just need to ensure they reference the guide prompt context
      
      // Extract key elements from guide prompt for variations (if needed for fallback)
      const baseElements = extractPromptElements(detectedGuidePrompt)
      
      // Concepts 2-6: Create variations maintaining consistency (fallback only if direct generation failed)
      for (let i = 1; i < Math.min(concepts.length, 6); i++) {
        const variationNumber = i + 1
        // Only create variation if prompt wasn't set by direct generation above
        if (!concepts[i].prompt || concepts[i].prompt.length < 50) {
          const variationPrompt = createVariationFromGuidePrompt(
            detectedGuidePrompt,
            baseElements,
            variationNumber,
            referenceImages,
            studioProMode
          )
          concepts[i].prompt = variationPrompt
        } else {
        }
      }
    }

    /**
     * Enhance prompt to explicitly reference image positions
     * This tells Nanobanana Pro which images to use for face vs outfit/styling
     */
    function enhancePromptForReferences(
      originalPrompt: string,
      numUserSelfies: number
    ): string {
      // Always add reference image instructions if not present
      const hasReferenceInstruction = /character consistency with provided reference images/i.test(originalPrompt)
      
      // Build specific image role instructions
      let imageRoleInstructions = ''
      
      if (numUserSelfies > 0) {
        // We have user selfies + concept #1
        const lastImageIndex = numUserSelfies + 1
        imageRoleInstructions = `Character consistency with provided reference images. Match the exact facial features, skin tone, and physical characteristics from reference images 1-${numUserSelfies}. Match the exact outfit, styling, hair, and accessories from reference image ${lastImageIndex}. This is the same person in a different scene.`
      } else {
        // Only concept #1 (no user selfies)
        imageRoleInstructions = `Character consistency with provided reference images. Match the exact facial features, outfit, styling, and characteristics from the reference image. This is the same person in a different scene.`
      }
      
      if (hasReferenceInstruction) {
        // Replace existing generic instruction with specific one
        return originalPrompt.replace(
          /Character consistency with provided reference images[^.]+\./i,
          imageRoleInstructions
        )
      } else {
        // Add reference instruction at the beginning (after trigger/character description)
        // Find where to insert (after first sentence or after character description)
        const sentences = originalPrompt.split(/[.!?]\s+/)
        if (sentences.length > 1) {
          // Insert after first sentence
          return sentences[0] + '. ' + imageRoleInstructions + ' ' + sentences.slice(1).join('. ')
        } else {
          // Add at beginning
          return imageRoleInstructions + ' ' + originalPrompt
        }
      }
    }

    // Post-process prompts to remove old requirements and ensure new simplified format
    // First, remove any old requirements that shouldn't be there
    // Track which concepts are from guide prompts (concept #1 and variations 2-6)
    // ðŸ”´ FIX: Use Local suffix to avoid conflicts with later definitions in different scopes
    const hasGuidePromptLocal1 = detectedGuidePrompt && detectedGuidePrompt.trim().length > 0
    const guidePromptHasBAndW = hasGuidePromptLocal1 && detectedGuidePrompt && /black.?and.?white|black\s*&\s*white|monochrome|b&w|grayscale/i.test(detectedGuidePrompt)
    
    // Helper function to check if a concept is a guide prompt (defined at line 2754)
    const isGuidePromptConceptFnLocal1 = (concept: MayaConcept) => 
      concept.title === 'Your Custom Prompt' && 
      concept.description === 'Using your guide prompt exactly as specified'
    
    // Safety check: ensure concepts is an array
    if (!Array.isArray(concepts)) {
      console.error("[v0] ERROR: concepts is not an array:", typeof concepts, concepts)
      concepts = []
    }
    
    concepts.forEach((concept, index) => {
      // Safety check: ensure concept exists and has required properties
      if (!concept) {
        console.warn(`[v0] Warning: concept at index ${index} is undefined, skipping`)
        return
      }
      if (!concept.prompt) {
        console.warn(`[v0] Warning: concept at index ${index} has no prompt, skipping`)
        return
      }
      
      let prompt = concept.prompt
      
      // Check if this is a guide prompt concept (concept #1 uses guide prompt, concepts 2-6 are variations)
      // ðŸ”´ FIX: Use the function to check each concept individually, not a boolean on all concepts
      const isFromGuidePrompt = isGuidePromptConceptFnLocal1(concept) || (hasGuidePromptLocal1 && index > 0 && index < 6)
      
      // ðŸ”´ðŸ”´ðŸ”´ CRITICAL: Remove "black and white" unless explicitly requested
      // BUT: Preserve B&W if it's in the original guide prompt
      if (studioProMode) {
        // Check if user explicitly requested B&W in their request
        const userExplicitlyWantsBAndW = /(?:black\s+and\s+white|monochrome|b&w|grayscale|black\s+white|black\s*&\s*white)\b/i.test(userRequest || "")
        const hasBAndWInPrompt = /black.?and.?white|black\s*&\s*white|monochrome|b&w|grayscale/i.test(prompt)
        
        // Remove B&W if not explicitly requested by user
        // BUT: If this is a guide prompt concept and the guide prompt has B&W, preserve it
        if (!userExplicitlyWantsBAndW && hasBAndWInPrompt && !(isFromGuidePrompt && guidePromptHasBAndW)) {
          // More aggressive removal - catch all variations
          prompt = prompt.replace(/,\s*black\s+and\s+white\s*$/gi, "") // At end
          prompt = prompt.replace(/,\s*black\s+and\s+white\s*[.,]/gi, "") // Before period/comma
          prompt = prompt.replace(/black\s+and\s+white,?\s*/gi, "") // Anywhere
          prompt = prompt.replace(/black\s*&\s*white,?\s*/gi, "") // B&W variation
          prompt = prompt.replace(/,\s*monochrome\s*$/gi, "") // At end
          prompt = prompt.replace(/,\s*monochrome\s*[.,]/gi, "") // Before period/comma
          prompt = prompt.replace(/monochrome,?\s*/gi, "") // Anywhere
          prompt = prompt.replace(/,\s*b&w\s*$/gi, "") // At end
          prompt = prompt.replace(/,\s*b&w\s*[.,]/gi, "") // Before period/comma
          prompt = prompt.replace(/b&w,?\s*/gi, "") // Anywhere
          prompt = prompt.replace(/,\s*grayscale\s*$/gi, "") // At end
          prompt = prompt.replace(/,\s*grayscale\s*[.,]/gi, "") // Before period/comma
          prompt = prompt.replace(/grayscale,?\s*/gi, "") // Anywhere
          // Clean up any double spaces or commas left behind
          prompt = prompt.replace(/\s+/g, " ").trim()
          prompt = prompt.replace(/,\s*,/g, ",")
          prompt = prompt.replace(/,\s*\./g, ".")
        }
      }
      
      // ðŸ”´ðŸ”´ðŸ”´ CRITICAL: Remove text overlays if workflowType is NOT carousel-slides, reel-cover, or text-overlay
      // BUT: Skip text overlay removal for guide prompt concepts (they should preserve the original guide prompt structure)
      if (studioProMode && workflowType !== "carousel-slides" && workflowType !== "reel-cover" && workflowType !== "text-overlay" && !isFromGuidePrompt) {
        // Remove entire TEXT OVERLAY sections (multiline, including everything until next section or end)
        prompt = prompt.replace(/\*\*TEXT\s+OVERLAY:\*\*[\s\S]*?(?=\*\*[A-Z]|$)/gi, "")
        prompt = prompt.replace(/TEXT\s+OVERLAY:\s*[\s\S]*?(?=\.\s*[A-Z]|$)/gi, "")
        prompt = prompt.replace(/TEXT\s+OVERLAY:\s*[\s\S]*?(?=\n\n|$)/gi, "")
        // Remove text overlay instructions (more aggressive patterns)
        prompt = prompt.replace(/,\s*text\s+placement:[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*font\s+size:[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*font\s+weight:[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*font\s+style:[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*text\s+color:[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*text\s+overlay\s+reading[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*text\s+positioned[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*text\s+must\s+be[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*text\s+is\s+prominent[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*background:\s*semi-transparent[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*semi-transparent\s+dark\s+overlay[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*safe\s+zones[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*readable\s+at\s+thumbnail[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*minimum\s+\d+:\d+\s+contrast\s+ratio[^,.]*[.,]/gi, "")
        // Remove standalone text overlay phrases
        prompt = prompt.replace(/,\s*text\s+overlay[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/text\s+overlay[^,.]*[.,]/gi, "")
        // Remove "Text is prominent" or similar phrases
        prompt = prompt.replace(/,\s*text\s+is\s+prominent[^,.]*[.,]/gi, "")
        prompt = prompt.replace(/,\s*subject\s+positioned\s+to\s+complement\s+text[^,.]*[.,]/gi, "")
        // Clean up any double periods or commas
        prompt = prompt.replace(/\.\s*\./g, ".")
        prompt = prompt.replace(/,\s*,/g, ",")
      }
      
      // Remove old requirements that are no longer needed
      // BUT: Be gentler with guide prompt concepts - only remove if they're clearly problematic
      if (!isFromGuidePrompt) {
        prompt = prompt.replace(/,\s*(film\s+grain|muted\s+tones|muted\s+color\s+palette|candid\s+moment|natural\s+skin\s+texture\s+with\s+pores\s+visible|not\s+airbrushed|not\s+plastic-looking|motion\s+blur|visible\s+sensor\s+noise|slight\s+motion\s+blur)/gi, "")
      }
      
      // Fix problematic poses that cause extra limbs
      // Replace "legs tucked under" with safer alternatives
      // BUT: Only fix if it's clearly problematic, preserve guide prompt poses
      if (/\blegs\s+tucked\s+under\b/i.test(prompt)) {
        prompt = prompt.replace(/\blegs\s+tucked\s+under\b/gi, "sitting with legs crossed")
      }
      if (/\bcurled\s+up\b/i.test(prompt)) {
        prompt = prompt.replace(/\bcurled\s+up\b/gi, "lounging comfortably")
      }
      if (/\bknees\s+to\s+chest\b/i.test(prompt)) {
        prompt = prompt.replace(/\bknees\s+to\s+chest\b/gi, "sitting with one knee up")
      }
      if (/\blegs\s+folded\s+under\b/i.test(prompt)) {
        prompt = prompt.replace(/\blegs\s+folded\s+under\b/gi, "sitting with legs crossed")
      }
      
      // For Studio Pro mode: Remove ALL iPhone/cellphone references
      // BUT: Skip for guide prompt concepts (they might have specific camera specs)
      if (studioProMode && !isFromGuidePrompt) {
        prompt = prompt.replace(/,\s*shot\s+on\s+iPhone[^,]*/gi, "")
        prompt = prompt.replace(/,\s*(amateur\s+cellphone\s+photo|cellphone\s+photo|amateur\s+photography|candid\s+photo|candid\s+moment)/gi, "")
        prompt = prompt.replace(/authentic\s+iPhone\s+photo\s+aesthetic/gi, "")
      } else if (!studioProMode) {
        // Remove duplicate "shot on iPhone" mentions (keep only one at the end)
        const iphoneMatches = prompt.match(/(shot\s+on\s+iPhone[^,]*)/gi)
        if (iphoneMatches && iphoneMatches.length > 1) {
          // Remove all iPhone mentions
          prompt = prompt.replace(/,\s*shot\s+on\s+iPhone[^,]*/gi, "")
          // Add one at the end in the new format
          prompt = `${prompt}, shot on iPhone 15 Pro portrait mode, shallow depth of field`
        }
      }
      
      // Clean up double commas and extra spaces
      prompt = prompt.replace(/,\s*,/g, ",").replace(/\s+/g, " ").trim()
      
      concept.prompt = prompt
    })
    
    const bannedWords = [
      "ultra realistic",
      "photorealistic",
      "8K",
      "4K",
      "high quality",
      "high resolution",
      "perfect",
      "flawless",
      "stunning",
      "beautiful",
      "gorgeous",
      "professional photography",
      "editorial",
      "magazine quality",
      "dramatic",
      "cinematic",
      "cinematic quality",
      "hyper detailed",
      "sharp focus",
      "ultra sharp",
      "crystal clear",
      "DSLR",
      "studio lighting",
      "professional lighting",
      "perfect lighting",
      "even lighting",
      "ideal lighting",
      "beautiful lighting",
      "smooth skin",
      "flawless skin",
      "airbrushed",
      "perfect skin",
      "silk-like skin",
    ]

    // CRITICAL FIX: Function to ensure all mandatory anti-plastic requirements are present
    // Now with conditional logic to respect user style requests AND reference image analysis
    // ðŸ”´ PRO MODE: Only add skin texture if it's in user prompt, guide prompt, or templates
    function ensureRequiredElements(
      prompt: string,
      currentWordCount: number,
      MAX_WORDS: number,
      userRequest?: string,
      aesthetic?: string,
      imageAnalysisText?: string,
      isStudioPro?: boolean,
      isEnhancedAuthenticity?: boolean,
      guidePrompt?: string,
      templateExamples?: string[],
    ): string {
      let enhanced = prompt
      let addedCount = 0

      // Combine user request, aesthetic, and image analysis for style detection
      const styleContext = `${userRequest || ""} ${aesthetic || ""} ${imageAnalysisText || ""}`.toLowerCase()

      // Detect if user wants professional/studio/magazine aesthetic (skip amateur requirements)
      const wantsProfessional = /magazine|cover|high.?end|high.?fashion|editorial|professional|luxury|fashion.?editorial|vogue|elle|runway/i.test(styleContext)
      const userExplicitStudio = /\b(studio\s+lighting|studio\s+shot|studio\s+photo|studio\s+images?|in\s+studio|photo\s+studio|studio\s+backdrop|studio\s+set|studio\s+session)\b/i.test(
        styleContext,
      )
      
      // Detect if user request is B&W/monochrome (NOT from image analysis - only user's explicit request)
      const wantsBAndW = /black.?and.?white|monochrome|b&w|grayscale|black and white/i.test(userRequest || "")
      
      // Detect if reference image shows studio lighting (explicit phrases only)
      const imageShowsStudio = /\b(studio\s+lighting|studio\s+shot|studio\s+photo|photo\s+studio|controlled\s+studio\s+lighting|professional\s+studio\s+lighting)\b/i.test(
        imageAnalysisText || "",
      )


      // ðŸ”´ CRITICAL: Check if skin texture should be included (from user prompt, guide prompt, or templates)
      // BUT: NEVER add in Studio Pro mode - Studio Pro uses professional photography without explicit skin texture mentions
      const shouldAddSkinTexture = shouldIncludeSkinTexture(userRequest, guidePrompt, templateExamples) && !isStudioPro
      
      // Check for natural skin texture - ONLY add if it should be included AND NOT in Studio Pro mode
      // Format: "natural skin texture with visible pores" (not "with visible pores" at the end)
      if (!/natural\s+skin\s+texture/i.test(enhanced)) {
        if (shouldAddSkinTexture) {
          // Insert before camera specs or at end if no camera specs
          if (/professional\s+photography|85mm|f\/|shot\s+on/i.test(enhanced)) {
            // Insert before camera specs
            enhanced = enhanced.replace(/(professional\s+photography|85mm|f\/|shot\s+on[^,]*)/i, "natural skin texture with visible pores, $1")
          } else {
            // Add before final period or at end
            enhanced = enhanced.replace(/(\.\s*$)/, ", natural skin texture with visible pores$1")
            if (!enhanced.includes("natural skin texture")) {
              enhanced += ", natural skin texture with visible pores"
            }
          }
          addedCount += 6
        } else {
          if (isStudioPro) {
          } else {
          }
        }
      }
      
      // Remove any incorrectly placed "with visible pores" at the end
      enhanced = enhanced.replace(/,\s*with\s+visible\s+pores\.?\s*$/i, "")
      enhanced = enhanced.replace(/with\s+visible\s+pores\.?\s*,\s*black\s+and\s+white/i, "black and white")
      enhanced = enhanced.replace(/\.\s*with\s+visible\s+pores\.?\s*$/i, ".")
      enhanced = enhanced.replace(/,\s*with\s+visible\s+pores\.?\s*,\s*black\s+and\s+white/i, ", black and white")
      
      // ðŸ”´ CRITICAL: For Studio Pro mode, ensure camera specs and lighting are included
      if (studioProMode) {
        // Ensure camera specs are present
        if (!/professional\s+photography|85mm|f\/\d|f\s*\d/i.test(enhanced)) {
          if (/natural\s+skin\s+texture/i.test(enhanced)) {
            enhanced = enhanced.replace(/(natural\s+skin\s+texture)/i, "professional photography, 85mm lens, f/2.0 depth of field, $1")
          } else {
            enhanced += ", professional photography, 85mm lens, f/2.0 depth of field"
          }
          addedCount += 6
        }
        
        // Ensure lighting description is present (check for lighting-related terms)
        // Pattern requires two words where second word must be lighting-related
        // This safely matches "natural light" but NOT "natural skin texture" (since "skin" isn't a lighting word)
        const hasLighting = /(?:soft|window|warm|ambient|mixed|color\s+temperatures|lighting|light|natural)\s+(?:light|lighting|window\s+light|ambient|illumination|shadows)/i.test(enhanced)
        if (!hasLighting) {
          // Add before camera specs if they exist, otherwise at end
          if (/professional\s+photography|85mm/i.test(enhanced)) {
            enhanced = enhanced.replace(/(professional\s+photography|85mm)/i, "soft natural lighting, $1")
          } else {
            enhanced += ", soft natural lighting"
          }
          addedCount += 3
        }
      }
      
      // Final cleanup
      enhanced = enhanced.replace(/,\s*,/g, ",").replace(/\s+/g, " ").trim()

      // Check for anti-plastic phrases (need at least 2 positive descriptors) - ONLY if skin texture should be included
      if (shouldAddSkinTexture) {
        const antiPlasticMatches =
          enhanced.match(/organic\s+imperfections|unretouched\s+skin|matte\s+skin\s+texture|realistic\s+texture|visible\s+pores|natural\s+imperfections/gi) || []
        const antiPlasticCount = antiPlasticMatches.length

        if (antiPlasticCount < 2) {
          const antiPlasticPhrases = [
            "organic imperfections",
            "unretouched skin texture",
            "matte skin texture",
            "realistic texture",
            "visible pores",
          ]
          const needed = Math.max(0, 2 - antiPlasticCount)
          if (needed > 0) {
            enhanced += ", " + antiPlasticPhrases.slice(0, needed).join(", ")
            addedCount += 2 * needed
          }
        }
      } else {
      }

      // Check for film grain (ALWAYS required - no exceptions)
      // Enhanced Authenticity mode: Use stronger film grain descriptions
      const hasFilmGrain = /film\s+grain|visible\s+film\s+grain|subtle\s+film\s+grain|prominent\s+film\s+grain/i.test(enhanced)
      if (!hasFilmGrain) {
        if (isEnhancedAuthenticity && !isStudioPro) {
          enhanced += ", visible film grain, grainy texture"
          addedCount += 5
        } else {
          enhanced += ", subtle film grain"
          addedCount += 3
        }
      } else if (isEnhancedAuthenticity && !isStudioPro && !/visible\s+film\s+grain|prominent\s+film\s+grain|grainy\s+texture/i.test(enhanced)) {
        // Upgrade to stronger film grain if enhanced authenticity is enabled
        enhanced = enhanced.replace(/subtle\s+film\s+grain/i, "visible film grain, grainy texture")
      }

      // PRIORITY 1 FIX #1: Make muted colors conditional on user request AND reference image
      // Check if user wants vibrant, pastel, high-contrast, B&W, or other non-muted styles
      const userWantsVibrant = /vibrant|bright|saturated|high.?contrast|bold.?colors|colorful|neon/i.test(styleContext)
      const userWantsPastel = /pastel|soft.?tones|gentle.?colors|light.?colors/i.test(styleContext)
      const userWantsMonochrome = /monochrome|black.?and.?white|b&w|grayscale/i.test(styleContext)
      const userWantsEditorial = /editorial|high.?fashion|fashion.?editorial|magazine/i.test(styleContext)

      // Check if prompt already has B&W/monochrome
      const hasBAndW = /black.?and.?white|monochrome|b&w|grayscale/i.test(enhanced)

      // ðŸ”´ CRITICAL: Only add B&W if explicitly requested by user (NOT from image analysis)
      // Do NOT add B&W based on image analysis - only user's explicit request
      const userExplicitlyWantsBAndW = /(?:black\s+and\s+white|monochrome|b&w|grayscale|black\s+white)\b/i.test(userRequest || "")

      if (!/muted\s+(?:colors?|color\s+palette|tones?)/i.test(enhanced)) {
        // Only add B&W if user explicitly requested it (NOT from image analysis)
        if (userExplicitlyWantsBAndW && !hasBAndW) {
          // User explicitly wants B&W - add it
          enhanced += ", black and white"
          addedCount += 3
        } else if (hasBAndW) {
          // B&W already in prompt - skip muted colors
        } else if (wantsProfessional) {
          // User wants vibrant - use "muted vibrant palette" as compromise (still authentic but respects request)
          enhanced += ", muted vibrant color palette"
          addedCount += 4
        } else if (userWantsPastel) {
          // User wants pastel - use "muted pastel tones" as compromise
          enhanced += ", muted pastel tones"
          addedCount += 3
        } else if (userWantsMonochrome) {
          // User wants monochrome - skip muted colors (monochrome is already muted)
        } else if (userWantsEditorial) {
          // User wants editorial - use "muted editorial palette" as compromise
          enhanced += ", muted editorial color palette"
          addedCount += 4
        } else {
          // Default: add muted colors (Scandinavian minimalism default)
          // Enhanced Authenticity mode: Use stronger muted color descriptions
          if (isEnhancedAuthenticity && !isStudioPro) {
            enhanced += ", heavily muted colors, desaturated color palette"
            addedCount += 4
          } else {
            enhanced += ", muted colors"
            addedCount += 2
          }
        }
      }

      // PRIORITY 1 FIX #2: Make uneven lighting conditional on user request AND reference image
      // Check if user wants dramatic, soft, golden hour, studio, or other specific lighting styles
      const userWantsDramatic = /dramatic|cinematic|editorial|high.?fashion|fashion.?editorial|striking/i.test(styleContext)
      const userWantsSoft = /soft|dreamy|gentle|diffused|soft.?glow|dreamy.?light/i.test(styleContext)
      const userWantsGoldenHour = /golden.?hour|warm.?glow|sunset|sunrise|warm.?light/i.test(styleContext)
      const userWantsMoody = /moody|dark|shadowy|deep.?shadows|low.?light/i.test(styleContext)
      // Check if prompt already has studio lighting
      const hasStudioLighting = /studio\s+lighting|professional\s+studio\s+lighting|dramatic\s+studio/i.test(enhanced)

      if (!/uneven\s+(?:natural\s+)?lighting|uneven\s+illumination/i.test(enhanced)) {
        // Check if user requested specific lighting style OR reference image shows studio
        if (userExplicitStudio || imageShowsStudio) {
          // User explicitly asked for studio OR reference shows studio - allow studio lighting
          if (!hasStudioLighting && !/studio/i.test(enhanced)) {
            enhanced += ", studio lighting"
            addedCount += 2
          }
        } else if (wantsProfessional) {
          // Professional vibe without explicit studio request - do not force studio lighting
        } else if (userWantsDramatic) {
          // User wants dramatic lighting - check if it's already in prompt or needs to be preserved
          if (/\b(?:dramatic|cinematic|editorial)\s+lighting/i.test(enhanced)) {
            // Already in prompt - keep it as-is, just ensure it's not "perfect"
            enhanced = enhanced.replace(/\bperfect\s+lighting\b/gi, "dramatic lighting")
          } else {
            // User wants dramatic but not in prompt yet - don't add "uneven", let Maya add dramatic
          }
        } else if (userWantsSoft) {
          // User wants soft lighting - check if it's already in prompt
          if (/\b(?:soft|dreamy|gentle|diffused)\s+lighting/i.test(enhanced)) {
            // Already in prompt - keep it, but add natural shadows for authenticity
            if (!/shadows|uneven/i.test(enhanced)) {
              enhanced = enhanced.replace(/\b(soft|dreamy|gentle|diffused)\s+lighting\b/gi, "$1 lighting with natural shadows")
              addedCount += 3
            }
          } else {
            // User wants soft but not in prompt yet - don't add "uneven", let Maya add soft
          }
        } else if (userWantsGoldenHour) {
          // User wants golden hour - check if it's already in prompt
          if (/\b(?:golden.?hour|warm.?glow|sunset|sunrise)\s+lighting/i.test(enhanced)) {
            // Already in prompt - keep it, but add natural variation
            if (!/uneven|variation|mixed/i.test(enhanced)) {
              enhanced = enhanced.replace(/\b(golden.?hour|warm.?glow|sunset|sunrise)\s+lighting\b/gi, "$1 lighting with natural variation")
              addedCount += 3
            }
          } else {
            // User wants golden hour but not in prompt yet - don't add "uneven", let Maya add golden hour
          }
        } else if (userWantsMoody) {
          // User wants moody lighting - check if it's already in prompt
          if (/\b(?:moody|dark|shadowy)\s+lighting/i.test(enhanced)) {
            // Already in prompt - keep it as-is (moody already implies uneven)
          } else {
            // User wants moody but not in prompt yet - don't add "uneven", let Maya add moody
          }
        } else {
          // Default: add uneven for natural lighting (Scandinavian minimalism default)
          // Only modify if lighting description exists but doesn't have "uneven"
          if (/\b(?:natural\s+)?lighting\b/i.test(enhanced) && !/uneven/i.test(enhanced)) {
            enhanced = enhanced.replace(/\b(natural\s+)?lighting\b/gi, "uneven $1lighting")
          }
        }
      }

      // Add authentic iPhone aesthetic at the end if not present (skip for professional/studio requests AND Studio Pro mode)
      // Enhanced Authenticity mode: Use stronger iPhone quality descriptions
      if (!isStudioPro && !wantsProfessional && !/authentic\s+iPhone\s+photo|iPhone\s+photo\s+aesthetic|amateur\s+iPhone/i.test(enhanced)) {
        if (isEnhancedAuthenticity) {
          enhanced += ", raw iPhone photo, authentic iPhone camera quality, amateur cellphone aesthetic"
          addedCount += 7
        } else {
          enhanced += ", authentic iPhone photo aesthetic"
          addedCount += 4
        }
      } else if (isStudioPro) {
      } else if (wantsProfessional) {
      } else if (isEnhancedAuthenticity && !isStudioPro && !wantsProfessional) {
        // Upgrade existing iPhone aesthetic to stronger version if enhanced authenticity is enabled
        if (/authentic\s+iPhone\s+photo\s+aesthetic/i.test(enhanced)) {
          enhanced = enhanced.replace(/authentic\s+iPhone\s+photo\s+aesthetic/i, "raw iPhone photo, authentic iPhone camera quality, amateur cellphone aesthetic")
        }
      }

      // Clean up any double commas or trailing commas
      enhanced = enhanced
        .replace(/,\s*,/g, ",")
        .replace(/^,\s*/, "")
        .replace(/\s*,\s*$/, "")
        .trim()


      return enhanced
    }

    // Redefine helper functions for this scope (originally defined at lines 2872 and 2868)
    // These are needed here because the previous definitions may be in a different scope
    const isGuidePromptConceptFnLocal = (concept: MayaConcept) => 
      concept.title === 'Your Custom Prompt' && 
      concept.description === 'Using your guide prompt exactly as specified'
    const hasGuidePromptLocal = detectedGuidePrompt && detectedGuidePrompt.trim().length > 0
    
    // Safety check: ensure concepts is an array
    if (!Array.isArray(concepts)) {
      console.error("[v0] ERROR: concepts is not an array in second forEach:", typeof concepts, concepts)
      concepts = []
    }
    
    // =============================================================================
    // MINIMAL SYNTAX CLEANUP
    // =============================================================================
    // Apply only essential syntax fixes - no content modifications
    // Trust Maya's generated prompts - she knows what she's doing!

    function minimalSyntaxCleanup(prompt: string, triggerWord: string): string {
      let clean = prompt
        .replace(/,\s*,/g, ',')  // Remove double commas
        .replace(/\s+/g, ' ')     // Normalize whitespace
        .trim()
      
      // Ensure trigger word is first (Classic Mode only)
      if (triggerWord && !clean.toLowerCase().startsWith(triggerWord.toLowerCase())) {
        clean = `${triggerWord}, ${clean}`
      }
      
      return clean
    }

    // Apply minimal cleanup to all concepts
    concepts.forEach((concept, index) => {
      if (concept.prompt) {
        const originalPrompt = concept.prompt
        concept.prompt = minimalSyntaxCleanup(concept.prompt, triggerWord || '')
        
        if (originalPrompt !== concept.prompt) {
        }
      }
    })


    // Add reference image URL if provided
    if (referenceImageUrl) {
      concepts.forEach((concept) => {
        if (!concept.referenceImageUrl) {
          concept.referenceImageUrl = referenceImageUrl
        }
      })
    }

    // Add seeds
    if (mode === "photoshoot") {
      if (photoshootBaseSeed !== null) {
        const baseSeed = photoshootBaseSeed // Type narrowing for closure
        concepts.forEach((concept, index) => {
          if (!concept.customSettings) {
            concept.customSettings = {}
          }
          concept.customSettings.seed = baseSeed + index
        })
      }
    } else {
      concepts.forEach((concept, index) => {
        if (!concept.customSettings) {
          concept.customSettings = {}
        }
        concept.customSettings.seed = Math.floor(Math.random() * 1000000)
      })
    }

    // Apply custom settings
    if (customSettings) {
      concepts.forEach((concept) => {
        concept.customSettings = {
          ...concept.customSettings,
          ...customSettings,
        }
      })
    }



    // ðŸ”´ CRITICAL: Log all final prompts before returning (what gets sent to frontend)
    concepts.slice(0, count).forEach((concept, idx) => {
    })

    return NextResponse.json({
      state: "ready",
      concepts: concepts.slice(0, count),
    })
  } catch (error) {
    console.error("[v0] Error generating concepts:", error)
    console.error("[v0] Error details:", {
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      name: error instanceof Error ? error.name : undefined
    })
    return NextResponse.json(
      {
        state: "error",
        message: "I need a bit more direction! What vibe are you going for?",
        error: process.env.NODE_ENV === "development" ? (error instanceof Error ? error.message : String(error)) : undefined,
      },
      { status: 500 },
    )
  }
}

// ============================================
// HELPER FUNCTIONS FOR UNIVERSAL PROMPTS
// ============================================

/**
 * Map Universal Prompt category to Maya category
 */
function mapUniversalCategoryToMaya(category: string): string {
  const mapping: Record<string, string> = {
    'travel-airport': 'Lifestyle',
    'alo-workout': 'Action',
    'seasonal-christmas': 'Lifestyle',
    'casual-lifestyle': 'Half Body',
    'luxury-fashion': 'Lifestyle'
  }
  return mapping[category] || 'Lifestyle'
}

/**
 * Extract fashion intelligence from prompt
 */
function extractFashionIntelligence(prompt: string): string {
  // Look for outfit section
  const outfitMatch = prompt.match(/(?:She wears|outfit:|wearing)([^\.]+\.|[^\.]{50,200})/i)
  if (outfitMatch) {
    return outfitMatch[1].trim()
  }
  return ''
}

/**
 * Extract lighting description from prompt
 */
function extractLighting(prompt: string): string {
  // Look for lighting section
  const lightingMatch = prompt.match(/Lighting:([^\.]+\.|[^\.]{50,200})/i)
  if (lightingMatch) {
    return lightingMatch[1].trim()
  }
  return ''
}

/**
 * Extract location description from prompt  
 */
function extractLocation(prompt: string): string {
  // Look for environment section
  const locationMatch = prompt.match(/Environment:([^\.]+\.|[^\.]{50,200})/i)
  if (locationMatch) {
    return locationMatch[1].trim()
  }
  return ''
}

