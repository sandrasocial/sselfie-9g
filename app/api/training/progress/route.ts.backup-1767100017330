import { type NextRequest, NextResponse } from "next/server"
import { createServerClient } from "@/lib/supabase/server"
import { getEffectiveNeonUser } from "@/lib/simple-impersonation"
import { getReplicateClient } from "@/lib/replicate-client"
import { neon } from "@neondatabase/serverless"

const sql = neon(process.env.DATABASE_URL!)

function extractProgressFromLogs(logs: string): number | null {
  if (!logs) return null

  const fluxStepMatch = logs.match(/step\s+(\d+)\/(\d+)/i)
  if (fluxStepMatch) {
    const current = Number.parseInt(fluxStepMatch[1], 10)
    const total = Number.parseInt(fluxStepMatch[2], 10)
    const progress = Math.round((current / total) * 100)
    if (progress > 0 && progress <= 100) {
      return progress
    }
  }

  const percentMatches = logs.match(/(\d+)%/g)
  if (percentMatches && percentMatches.length > 0) {
    // Get the last percentage mentioned (most recent progress)
    const lastPercent = percentMatches[percentMatches.length - 1]
    const percentValue = Number.parseInt(lastPercent, 10)
    // Only return if it's a meaningful progress value
    if (percentValue > 0 && percentValue <= 100) {
      return percentValue
    }
  }

  const epochMatch = logs.match(/epoch\s+(\d+)\/(\d+)/i)
  if (epochMatch) {
    const current = Number.parseInt(epochMatch[1], 10)
    const total = Number.parseInt(epochMatch[2], 10)
    const progress = Math.round((current / total) * 100)
    if (progress > 0 && progress <= 100) {
      return progress
    }
  }

  return null
}

function estimateProgress(startedAt: Date, status: string): number {
  const elapsed = Date.now() - new Date(startedAt).getTime()
  const elapsedMinutes = elapsed / (60 * 1000)

  const estimatedTotalMinutes = 5

  if (status === "starting") {
    return Math.min(10, Math.round((elapsedMinutes / estimatedTotalMinutes) * 100))
  } else if (status === "processing") {
    const baseProgress = 10
    const maxProgress = 95
    const progressRange = maxProgress - baseProgress

    const timeProgress = (elapsedMinutes / estimatedTotalMinutes) * 100
    const estimatedProgress = baseProgress + (timeProgress * progressRange) / 100

    return Math.min(maxProgress, Math.max(baseProgress, Math.round(estimatedProgress)))
  }

  return 10
}

function calculateRemainingMinutes(startedAt: Date, currentProgress: number): number {
  const elapsed = Date.now() - new Date(startedAt).getTime()
  const elapsedMinutes = elapsed / (60 * 1000)

  // Avoid division by zero
  if (currentProgress <= 0 || currentProgress >= 100) {
    return 0
  }

  // Calculate estimated total time based on current progress and elapsed time
  const estimatedTotalMinutes = (elapsedMinutes / currentProgress) * 100

  // Calculate remaining time
  const remainingMinutes = Math.max(0, estimatedTotalMinutes - elapsedMinutes)

  return Math.round(remainingMinutes)
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const modelId = searchParams.get("modelId")


    if (!modelId) {
      return NextResponse.json({ error: "Model ID required" }, { status: 400 })
    }

    // Get authenticated user
    const supabase = await createServerClient()
    const {
      data: { user: authUser },
    } = await supabase.auth.getUser()

    if (!authUser) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const neonUser = await getEffectiveNeonUser(authUser.id)
    if (!neonUser) {
      return NextResponse.json({ error: "User not found" }, { status: 404 })
    }

    const models = await sql`
      SELECT 
        id, 
        user_id, 
        replicate_model_id, 
        trigger_word, 
        training_status, 
        training_progress, 
        training_id,
        started_at,
        created_at,
        completed_at,
        replicate_version_id,
        lora_weights_url,
        failure_reason,
        estimated_completion_time,
        updated_at,
        model_name,
        trained_model_path,
        lora_scale
      FROM user_models
      WHERE id = ${modelId} AND user_id = ${neonUser.id}
    `

    if (models.length === 0) {
      return NextResponse.json({ error: "Model not found" }, { status: 404 })
    }

    const model = models[0]

      try {
        const replicate = getReplicateClient()
        const training = await replicate.trainings.get(model.training_id)

          } else {
            // Try to extract progress from logs first
            const logProgress = extractProgressFromLogs(training.logs || "")
            if (logProgress !== null) {
              progress = logProgress
              debugInfo.progressSource = "logs"
              debugInfo.extractedProgress = logProgress
            } else {
              // Estimate based on elapsed time
              const startTime = model.started_at || model.created_at
              progress = estimateProgress(startTime, training.status)
              debugInfo.progressSource = "estimated"
              debugInfo.estimatedProgress = progress
              debugInfo.startedAt = startTime
              debugInfo.elapsedMinutes = Math.round((Date.now() - new Date(startTime).getTime()) / 60000)
            }
          }
        }


        // Update database with latest status
        if (training.status === "succeeded") {
          let loraWeightsUrl = null
          let extractionMethod = "none"

          // CRITICAL: Try multiple ways to get the LoRA weights URL
          // This must be consistent for both first-time training and retraining
          if (training.output) {
            // Method 1: Direct weights URL (most reliable)
            if (training.output.weights) {
              loraWeightsUrl = training.output.weights
              extractionMethod = "direct_weights"
            }
            // Method 2: Version-based URL (construct from version hash)
            else if (training.output.version) {
              // Extract version hash if it's in format "model:hash"
              const versionHash = training.output.version.includes(':')
                ? training.output.version.split(':')[1]
                : training.output.version
              
              loraWeightsUrl = `https://replicate.delivery/pbxt/${versionHash}/flux-lora.tar`
              extractionMethod = "version_constructed"
            }
            // Method 3: Check if output is a string URL
            else if (typeof training.output === "string" && training.output.startsWith("http")) {
              loraWeightsUrl = training.output
              extractionMethod = "string_url"
            }
          }

          if (!loraWeightsUrl) {
            console.error("[v0] ❌ CRITICAL: Failed to extract LoRA weights URL!")
            console.error("[v0] Training output:", JSON.stringify(training.output, null, 2))
            // Try fallback: construct from model version if we have it
            if (training.output?.model && training.output?.version) {
              const versionHash = training.output.version.includes(':')
                ? training.output.version.split(':')[1]
                : training.output.version
              loraWeightsUrl = `https://replicate.delivery/pbxt/${versionHash}/flux-lora.tar`
              extractionMethod = "fallback_constructed"
            }
          }

          
          if (!loraWeightsUrl) {
            console.error("[v0] ❌ CRITICAL ERROR: LoRA weights URL is NULL after all extraction methods!")
            console.error("[v0] This will cause image generation to fail!")
          }

          // CRITICAL FIX: Extract version hash properly from training.output.version
          // training.output.version can be:
          // 1. Full format: "sandrasocial/user-50c-selfie-lora:4e0de78d"
          // 2. Just hash: "4e0de78d"
          // We need to store JUST the hash for predictions.create({ version: "hash" })
          let versionHash = null
          if (training.output?.version) {
            versionHash = training.output.version.includes(':')
              ? training.output.version.split(':')[1]  // Extract hash from "model:hash"
              : training.output.version  // Already just hash
          } else {
            console.warn("[v0] ⚠️ No version in training.output, keeping existing version")
            versionHash = model.replicate_version_id
          }

          // CRITICAL: Verify we're using the destination model version, not trainer version
          // If we have the model ID, we can optionally fetch the latest version to ensure it's correct
          const replicateModelId = training.output?.model || model.replicate_model_id
          if (replicateModelId && versionHash) {
            try {
              // Fetch latest version from destination model to verify
              const modelResponse = await fetch(`https://api.replicate.com/v1/models/${replicateModelId}/versions`, {
                headers: {
                  Authorization: `Bearer ${process.env.REPLICATE_API_TOKEN}`,
                },
              })
              
              if (modelResponse.ok) {
                const versionsData = await modelResponse.json()
                const latestVersion = versionsData.results?.[0]?.id
                
                if (latestVersion && latestVersion !== versionHash) {
                  console.warn(`[v0] ⚠️ Version mismatch detected! DB has ${versionHash}, latest is ${latestVersion}`)
                  versionHash = latestVersion
                  
                  // Update LoRA URL if we're using version-based construction
                  if (extractionMethod === "version_constructed" || extractionMethod === "fallback_constructed") {
                    loraWeightsUrl = `https://replicate.delivery/pbxt/${versionHash}/flux-lora.tar`
                  }
                } else if (latestVersion === versionHash) {
                }
              }
            } catch (versionCheckError) {
              console.warn("[v0] ⚠️ Could not verify version with Replicate API, using extracted version:", versionCheckError)
              // Continue with extracted version if verification fails
            }
          }

          // CRITICAL: Preserve existing LoRA scale if it was customized (not default 1.0)
          // Only set to 1.0 if it was never set or is null
          // This ensures retraining doesn't reset a custom LoRA scale
          const preservedLoraScale = model.lora_scale && parseFloat(model.lora_scale) !== 1.0
            ? model.lora_scale
            : 1.0

          await sql`
            UPDATE user_models
            SET 
              training_progress = ${progress},
              updated_at = NOW()
            WHERE id = ${modelId}
          `

          return NextResponse.json({
            status: "training",
            progress: progress,
            estimated_remaining_minutes: calculateRemainingMinutes(model.started_at || model.created_at, progress),
            model: {
              ...model,
              training_progress: progress,
            },
            debug: debugInfo,
          })
        }
      } catch (replicateError: any) {
        const errorMessage = replicateError?.message || String(replicateError)
        const isTemporaryError =
          errorMessage.includes("502") ||
          errorMessage.includes("503") ||
          errorMessage.includes("Bad gateway") ||
          errorMessage.includes("Service unavailable")

        debugInfo.replicateError = errorMessage
        debugInfo.isTemporaryError = isTemporaryError

        console.error("[v0] Error checking Replicate status:", {
          error: errorMessage,
          isTemporary: isTemporaryError,
          trainingId: model.training_id,
        })

        // For temporary errors, estimate progress and continue showing training state
        if (isTemporaryError && model.training_status === "training") {
          const startTime = model.started_at || model.created_at
          const estimatedProgress = estimateProgress(startTime, "processing")


          // Update progress in database
          await sql`
            UPDATE user_models
            SET 
              training_progress = ${estimatedProgress},
              updated_at = NOW()
            WHERE id = ${modelId}
          `

          return NextResponse.json({
            status: "training",
            progress: estimatedProgress,
            estimated_remaining_minutes: calculateRemainingMinutes(
              model.started_at || model.created_at,
              estimatedProgress,
            ),
            model: {
              ...model,
              training_progress: estimatedProgress,
            },
            debug: debugInfo,
            warning: "Replicate API temporarily unavailable. Using estimated progress.",
          })
        }

        // For other errors or non-training states, return current database status
        return NextResponse.json({
          status: model.training_status,
          progress: model.training_progress || 0,
          model: model,
          debug: debugInfo,
          error: isTemporaryError ? "Replicate API temporarily unavailable" : "Failed to check Replicate status",
        })
      }
    } else {
      debugInfo.reason = "No training_id in database"
    }

    return NextResponse.json({
      status: model.training_status,
      progress: model.training_progress || 0,
      model: model,
      debug: debugInfo,
    })
  } catch (error) {
    console.error("[v0] Error checking training progress:", error)
    return NextResponse.json(
      {
        error: "Failed to check training progress",
        details: error instanceof Error ? error.message : String(error),
      },
      { status: 500 },
    )
  }
}
